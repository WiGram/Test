Help on package scipy.stats in scipy:

NNAAMMEE
    scipy.stats

DDEESSCCRRIIPPTTIIOONN
    ==========================================
    Statistical functions (:mod:`scipy.stats`)
    ==========================================
    
    .. module:: scipy.stats
    
    This module contains a large number of probability distributions as
    well as a growing library of statistical functions.
    
    Each univariate distribution is an instance of a subclass of `rv_continuous`
    (`rv_discrete` for discrete distributions):
    
    .. autosummary::
       :toctree: generated/
    
       rv_continuous
       rv_discrete
       rv_histogram
    
    Continuous distributions
    ========================
    
    .. autosummary::
       :toctree: generated/
    
       alpha             -- Alpha
       anglit            -- Anglit
       arcsine           -- Arcsine
       argus             -- Argus
       beta              -- Beta
       betaprime         -- Beta Prime
       bradford          -- Bradford
       burr              -- Burr (Type III)
       burr12            -- Burr (Type XII)
       cauchy            -- Cauchy
       chi               -- Chi
       chi2              -- Chi-squared
       cosine            -- Cosine
       crystalball       -- Crystalball
       dgamma            -- Double Gamma
       dweibull          -- Double Weibull
       erlang            -- Erlang
       expon             -- Exponential
       exponnorm         -- Exponentially Modified Normal
       exponweib         -- Exponentiated Weibull
       exponpow          -- Exponential Power
       f                 -- F (Snecdor F)
       fatiguelife       -- Fatigue Life (Birnbaum-Saunders)
       fisk              -- Fisk
       foldcauchy        -- Folded Cauchy
       foldnorm          -- Folded Normal
       frechet_r         -- Deprecated. Alias for weibull_min
       frechet_l         -- Deprecated. Alias for weibull_max
       genlogistic       -- Generalized Logistic
       gennorm           -- Generalized normal
       genpareto         -- Generalized Pareto
       genexpon          -- Generalized Exponential
       genextreme        -- Generalized Extreme Value
       gausshyper        -- Gauss Hypergeometric
       gamma             -- Gamma
       gengamma          -- Generalized gamma
       genhalflogistic   -- Generalized Half Logistic
       gilbrat           -- Gilbrat
       gompertz          -- Gompertz (Truncated Gumbel)
       gumbel_r          -- Right Sided Gumbel, Log-Weibull, Fisher-Tippett, Extreme Value Type I
       gumbel_l          -- Left Sided Gumbel, etc.
       halfcauchy        -- Half Cauchy
       halflogistic      -- Half Logistic
       halfnorm          -- Half Normal
       halfgennorm       -- Generalized Half Normal
       hypsecant         -- Hyperbolic Secant
       invgamma          -- Inverse Gamma
       invgauss          -- Inverse Gaussian
       invweibull        -- Inverse Weibull
       johnsonsb         -- Johnson SB
       johnsonsu         -- Johnson SU
       kappa4            -- Kappa 4 parameter
       kappa3            -- Kappa 3 parameter
       ksone             -- Kolmogorov-Smirnov one-sided (no stats)
       kstwobign         -- Kolmogorov-Smirnov two-sided test for Large N (no stats)
       laplace           -- Laplace
       levy              -- Levy
       levy_l
       levy_stable
       logistic          -- Logistic
       loggamma          -- Log-Gamma
       loglaplace        -- Log-Laplace (Log Double Exponential)
       lognorm           -- Log-Normal
       lomax             -- Lomax (Pareto of the second kind)
       maxwell           -- Maxwell
       mielke            -- Mielke's Beta-Kappa
       moyal             -- Moyal
       nakagami          -- Nakagami
       ncx2              -- Non-central chi-squared
       ncf               -- Non-central F
       nct               -- Non-central Student's T
       norm              -- Normal (Gaussian)
       norminvgauss      -- Normal Inverse Gaussian
       pareto            -- Pareto
       pearson3          -- Pearson type III
       powerlaw          -- Power-function
       powerlognorm      -- Power log normal
       powernorm         -- Power normal
       rdist             -- R-distribution
       reciprocal        -- Reciprocal
       rayleigh          -- Rayleigh
       rice              -- Rice
       recipinvgauss     -- Reciprocal Inverse Gaussian
       semicircular      -- Semicircular
       skewnorm          -- Skew normal
       t                 -- Student's T
       trapz              -- Trapezoidal
       triang            -- Triangular
       truncexpon        -- Truncated Exponential
       truncnorm         -- Truncated Normal
       tukeylambda       -- Tukey-Lambda
       uniform           -- Uniform
       vonmises          -- Von-Mises (Circular)
       vonmises_line     -- Von-Mises (Line)
       wald              -- Wald
       weibull_min       -- Minimum Weibull (see Frechet)
       weibull_max       -- Maximum Weibull (see Frechet)
       wrapcauchy        -- Wrapped Cauchy
    
    Multivariate distributions
    ==========================
    
    .. autosummary::
       :toctree: generated/
    
       multivariate_normal   -- Multivariate normal distribution
       matrix_normal         -- Matrix normal distribution
       dirichlet             -- Dirichlet
       wishart               -- Wishart
       invwishart            -- Inverse Wishart
       multinomial           -- Multinomial distribution
       special_ortho_group   -- SO(N) group
       ortho_group           -- O(N) group
       unitary_group         -- U(N) group
       random_correlation    -- random correlation matrices
    
    Discrete distributions
    ======================
    
    .. autosummary::
       :toctree: generated/
    
       bernoulli         -- Bernoulli
       binom             -- Binomial
       boltzmann         -- Boltzmann (Truncated Discrete Exponential)
       dlaplace          -- Discrete Laplacian
       geom              -- Geometric
       hypergeom         -- Hypergeometric
       logser            -- Logarithmic (Log-Series, Series)
       nbinom            -- Negative Binomial
       planck            -- Planck (Discrete Exponential)
       poisson           -- Poisson
       randint           -- Discrete Uniform
       skellam           -- Skellam
       zipf              -- Zipf
    
    Statistical functions
    =====================
    
    Several of these functions have a similar version in scipy.stats.mstats
    which work for masked arrays.
    
    .. autosummary::
       :toctree: generated/
    
       describe          -- Descriptive statistics
       gmean             -- Geometric mean
       hmean             -- Harmonic mean
       kurtosis          -- Fisher or Pearson kurtosis
       kurtosistest      --
       mode              -- Modal value
       moment            -- Central moment
       normaltest        --
       skew              -- Skewness
       skewtest          --
       kstat             --
       kstatvar          --
       tmean             -- Truncated arithmetic mean
       tvar              -- Truncated variance
       tmin              --
       tmax              --
       tstd              --
       tsem              --
       variation         -- Coefficient of variation
       find_repeats
       trim_mean
    
    .. autosummary::
       :toctree: generated/
    
       cumfreq
       itemfreq
       percentileofscore
       scoreatpercentile
       relfreq
    
    .. autosummary::
       :toctree: generated/
    
       binned_statistic     -- Compute a binned statistic for a set of data.
       binned_statistic_2d  -- Compute a 2-D binned statistic for a set of data.
       binned_statistic_dd  -- Compute a d-D binned statistic for a set of data.
    
    .. autosummary::
       :toctree: generated/
    
       obrientransform
       bayes_mvs
       mvsdist
       sem
       zmap
       zscore
       iqr
    
    .. autosummary::
       :toctree: generated/
    
       sigmaclip
       trimboth
       trim1
    
    .. autosummary::
       :toctree: generated/
    
       f_oneway
       pearsonr
       spearmanr
       pointbiserialr
       kendalltau
       weightedtau
       linregress
       theilslopes
    
    .. autosummary::
       :toctree: generated/
    
       ttest_1samp
       ttest_ind
       ttest_ind_from_stats
       ttest_rel
       kstest
       chisquare
       power_divergence
       ks_2samp
       mannwhitneyu
       tiecorrect
       rankdata
       ranksums
       wilcoxon
       kruskal
       friedmanchisquare
       combine_pvalues
       jarque_bera
    
    .. autosummary::
       :toctree: generated/
    
       ansari
       bartlett
       levene
       shapiro
       anderson
       anderson_ksamp
       binom_test
       fligner
       median_test
       mood
    
    .. autosummary::
       :toctree: generated/
    
       boxcox
       boxcox_normmax
       boxcox_llf
    
       entropy
    
    .. autosummary::
       :toctree: generated/
    
       wasserstein_distance
       energy_distance
    
    Circular statistical functions
    ==============================
    
    .. autosummary::
       :toctree: generated/
    
       circmean
       circvar
       circstd
    
    Contingency table functions
    ===========================
    
    .. autosummary::
       :toctree: generated/
    
       chi2_contingency
       contingency.expected_freq
       contingency.margins
       fisher_exact
    
    Plot-tests
    ==========
    
    .. autosummary::
       :toctree: generated/
    
       ppcc_max
       ppcc_plot
       probplot
       boxcox_normplot
    
    
    Masked statistics functions
    ===========================
    
    .. toctree::
    
       stats.mstats
    
    
    Univariate and multivariate kernel density estimation (:mod:`scipy.stats.kde`)
    ==============================================================================
    
    .. autosummary::
       :toctree: generated/
    
       gaussian_kde
    
    For many more stat related functions install the software R and the
    interface package rpy.

PPAACCKKAAGGEE  CCOONNTTEENNTTSS
    _binned_statistic
    _constants
    _continuous_distns
    _discrete_distns
    _distn_infrastructure
    _distr_params
    _multivariate
    _stats
    _stats_mstats_common
    _tukeylambda_stats
    contingency
    distributions
    kde
    morestats
    mstats
    mstats_basic
    mstats_extras
    mvn
    setup
    statlib
    stats
    tests (package)
    vonmises

CCLLAASSSSEESS
    builtins.object
        scipy.stats.kde.gaussian_kde
    scipy.stats._distn_infrastructure.rv_generic(builtins.object)
        scipy.stats._distn_infrastructure.rv_continuous
            scipy.stats._continuous_distns.rv_histogram
        scipy.stats._distn_infrastructure.rv_discrete
    
    class ggaauussssiiaann__kkddee(builtins.object)
     |  gaussian_kde(dataset, bw_method=None)
     |  
     |  Representation of a kernel-density estimate using Gaussian kernels.
     |  
     |  Kernel density estimation is a way to estimate the probability density
     |  function (PDF) of a random variable in a non-parametric way.
     |  `gaussian_kde` works for both uni-variate and multi-variate data.   It
     |  includes automatic bandwidth determination.  The estimation works best for
     |  a unimodal distribution; bimodal or multi-modal distributions tend to be
     |  oversmoothed.
     |  
     |  Parameters
     |  ----------
     |  dataset : array_like
     |      Datapoints to estimate from. In case of univariate data this is a 1-D
     |      array, otherwise a 2-D array with shape (# of dims, # of data).
     |  bw_method : str, scalar or callable, optional
     |      The method used to calculate the estimator bandwidth.  This can be
     |      'scott', 'silverman', a scalar constant or a callable.  If a scalar,
     |      this will be used directly as `kde.factor`.  If a callable, it should
     |      take a `gaussian_kde` instance as only parameter and return a scalar.
     |      If None (default), 'scott' is used.  See Notes for more details.
     |  
     |  Attributes
     |  ----------
     |  dataset : ndarray
     |      The dataset with which `gaussian_kde` was initialized.
     |  d : int
     |      Number of dimensions.
     |  n : int
     |      Number of datapoints.
     |  factor : float
     |      The bandwidth factor, obtained from `kde.covariance_factor`, with which
     |      the covariance matrix is multiplied.
     |  covariance : ndarray
     |      The covariance matrix of `dataset`, scaled by the calculated bandwidth
     |      (`kde.factor`).
     |  inv_cov : ndarray
     |      The inverse of `covariance`.
     |  
     |  Methods
     |  -------
     |  evaluate
     |  __call__
     |  integrate_gaussian
     |  integrate_box_1d
     |  integrate_box
     |  integrate_kde
     |  pdf
     |  logpdf
     |  resample
     |  set_bandwidth
     |  covariance_factor
     |  
     |  Notes
     |  -----
     |  Bandwidth selection strongly influences the estimate obtained from the KDE
     |  (much more so than the actual shape of the kernel).  Bandwidth selection
     |  can be done by a "rule of thumb", by cross-validation, by "plug-in
     |  methods" or by other means; see [3]_, [4]_ for reviews.  `gaussian_kde`
     |  uses a rule of thumb, the default is Scott's Rule.
     |  
     |  Scott's Rule [1]_, implemented as `scotts_factor`, is::
     |  
     |      n**(-1./(d+4)),
     |  
     |  with ``n`` the number of data points and ``d`` the number of dimensions.
     |  Silverman's Rule [2]_, implemented as `silverman_factor`, is::
     |  
     |      (n * (d + 2) / 4.)**(-1. / (d + 4)).
     |  
     |  Good general descriptions of kernel density estimation can be found in [1]_
     |  and [2]_, the mathematics for this multi-dimensional implementation can be
     |  found in [1]_.
     |  
     |  References
     |  ----------
     |  .. [1] D.W. Scott, "Multivariate Density Estimation: Theory, Practice, and
     |         Visualization", John Wiley & Sons, New York, Chicester, 1992.
     |  .. [2] B.W. Silverman, "Density Estimation for Statistics and Data
     |         Analysis", Vol. 26, Monographs on Statistics and Applied Probability,
     |         Chapman and Hall, London, 1986.
     |  .. [3] B.A. Turlach, "Bandwidth Selection in Kernel Density Estimation: A
     |         Review", CORE and Institut de Statistique, Vol. 19, pp. 1-33, 1993.
     |  .. [4] D.M. Bashtannyk and R.J. Hyndman, "Bandwidth selection for kernel
     |         conditional density estimation", Computational Statistics & Data
     |         Analysis, Vol. 36, pp. 279-298, 2001.
     |  
     |  Examples
     |  --------
     |  Generate some random two-dimensional data:
     |  
     |  >>> from scipy import stats
     |  >>> def measure(n):
     |  ...     "Measurement model, return two coupled measurements."
     |  ...     m1 = np.random.normal(size=n)
     |  ...     m2 = np.random.normal(scale=0.5, size=n)
     |  ...     return m1+m2, m1-m2
     |  
     |  >>> m1, m2 = measure(2000)
     |  >>> xmin = m1.min()
     |  >>> xmax = m1.max()
     |  >>> ymin = m2.min()
     |  >>> ymax = m2.max()
     |  
     |  Perform a kernel density estimate on the data:
     |  
     |  >>> X, Y = np.mgrid[xmin:xmax:100j, ymin:ymax:100j]
     |  >>> positions = np.vstack([X.ravel(), Y.ravel()])
     |  >>> values = np.vstack([m1, m2])
     |  >>> kernel = stats.gaussian_kde(values)
     |  >>> Z = np.reshape(kernel(positions).T, X.shape)
     |  
     |  Plot the results:
     |  
     |  >>> import matplotlib.pyplot as plt
     |  >>> fig, ax = plt.subplots()
     |  >>> ax.imshow(np.rot90(Z), cmap=plt.cm.gist_earth_r,
     |  ...           extent=[xmin, xmax, ymin, ymax])
     |  >>> ax.plot(m1, m2, 'k.', markersize=2)
     |  >>> ax.set_xlim([xmin, xmax])
     |  >>> ax.set_ylim([ymin, ymax])
     |  >>> plt.show()
     |  
     |  Methods defined here:
     |  
     |  ____ccaallll____ = evaluate(self, points)
     |  
     |  ____iinniitt____(self, dataset, bw_method=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ccoovvaarriiaannccee__ffaaccttoorr = scotts_factor(self)
     |  
     |  eevvaalluuaattee(self, points)
     |      Evaluate the estimated pdf on a set of points.
     |      
     |      Parameters
     |      ----------
     |      points : (# of dimensions, # of points)-array
     |          Alternatively, a (# of dimensions,) vector can be passed in and
     |          treated as a single point.
     |      
     |      Returns
     |      -------
     |      values : (# of points,)-array
     |          The values at each point.
     |      
     |      Raises
     |      ------
     |      ValueError : if the dimensionality of the input points is different than
     |                   the dimensionality of the KDE.
     |  
     |  iinntteeggrraattee__bbooxx(self, low_bounds, high_bounds, maxpts=None)
     |      Computes the integral of a pdf over a rectangular interval.
     |      
     |      Parameters
     |      ----------
     |      low_bounds : array_like
     |          A 1-D array containing the lower bounds of integration.
     |      high_bounds : array_like
     |          A 1-D array containing the upper bounds of integration.
     |      maxpts : int, optional
     |          The maximum number of points to use for integration.
     |      
     |      Returns
     |      -------
     |      value : scalar
     |          The result of the integral.
     |  
     |  iinntteeggrraattee__bbooxx__11dd(self, low, high)
     |      Computes the integral of a 1D pdf between two bounds.
     |      
     |      Parameters
     |      ----------
     |      low : scalar
     |          Lower bound of integration.
     |      high : scalar
     |          Upper bound of integration.
     |      
     |      Returns
     |      -------
     |      value : scalar
     |          The result of the integral.
     |      
     |      Raises
     |      ------
     |      ValueError
     |          If the KDE is over more than one dimension.
     |  
     |  iinntteeggrraattee__ggaauussssiiaann(self, mean, cov)
     |      Multiply estimated density by a multivariate Gaussian and integrate
     |      over the whole space.
     |      
     |      Parameters
     |      ----------
     |      mean : aray_like
     |          A 1-D array, specifying the mean of the Gaussian.
     |      cov : array_like
     |          A 2-D array, specifying the covariance matrix of the Gaussian.
     |      
     |      Returns
     |      -------
     |      result : scalar
     |          The value of the integral.
     |      
     |      Raises
     |      ------
     |      ValueError
     |          If the mean or covariance of the input Gaussian differs from
     |          the KDE's dimensionality.
     |  
     |  iinntteeggrraattee__kkddee(self, other)
     |      Computes the integral of the product of this  kernel density estimate
     |      with another.
     |      
     |      Parameters
     |      ----------
     |      other : gaussian_kde instance
     |          The other kde.
     |      
     |      Returns
     |      -------
     |      value : scalar
     |          The result of the integral.
     |      
     |      Raises
     |      ------
     |      ValueError
     |          If the KDEs have different dimensionality.
     |  
     |  llooggppddff(self, x)
     |      Evaluate the log of the estimated pdf on a provided set of points.
     |  
     |  ppddff(self, x)
     |      Evaluate the estimated pdf on a provided set of points.
     |      
     |      Notes
     |      -----
     |      This is an alias for `gaussian_kde.evaluate`.  See the ``evaluate``
     |      docstring for more details.
     |  
     |  rreessaammppllee(self, size=None)
     |      Randomly sample a dataset from the estimated pdf.
     |      
     |      Parameters
     |      ----------
     |      size : int, optional
     |          The number of samples to draw.  If not provided, then the size is
     |          the same as the underlying dataset.
     |      
     |      Returns
     |      -------
     |      resample : (self.d, `size`) ndarray
     |          The sampled dataset.
     |  
     |  ssccoottttss__ffaaccttoorr(self)
     |      Computes the coefficient (`kde.factor`) that
     |      multiplies the data covariance matrix to obtain the kernel covariance
     |      matrix. The default is `scotts_factor`.  A subclass can overwrite this
     |      method to provide a different method, or set it through a call to
     |      `kde.set_bandwidth`.
     |  
     |  sseett__bbaannddwwiiddtthh(self, bw_method=None)
     |      Compute the estimator bandwidth with given method.
     |      
     |      The new bandwidth calculated after a call to `set_bandwidth` is used
     |      for subsequent evaluations of the estimated density.
     |      
     |      Parameters
     |      ----------
     |      bw_method : str, scalar or callable, optional
     |          The method used to calculate the estimator bandwidth.  This can be
     |          'scott', 'silverman', a scalar constant or a callable.  If a
     |          scalar, this will be used directly as `kde.factor`.  If a callable,
     |          it should take a `gaussian_kde` instance as only parameter and
     |          return a scalar.  If None (default), nothing happens; the current
     |          `kde.covariance_factor` method is kept.
     |      
     |      Notes
     |      -----
     |      .. versionadded:: 0.11
     |      
     |      Examples
     |      --------
     |      >>> import scipy.stats as stats
     |      >>> x1 = np.array([-7, -5, 1, 4, 5.])
     |      >>> kde = stats.gaussian_kde(x1)
     |      >>> xs = np.linspace(-10, 10, num=50)
     |      >>> y1 = kde(xs)
     |      >>> kde.set_bandwidth(bw_method='silverman')
     |      >>> y2 = kde(xs)
     |      >>> kde.set_bandwidth(bw_method=kde.factor / 3.)
     |      >>> y3 = kde(xs)
     |      
     |      >>> import matplotlib.pyplot as plt
     |      >>> fig, ax = plt.subplots()
     |      >>> ax.plot(x1, np.ones(x1.shape) / (4. * x1.size), 'bo',
     |      ...         label='Data points (rescaled)')
     |      >>> ax.plot(xs, y1, label='Scott (default)')
     |      >>> ax.plot(xs, y2, label='Silverman')
     |      >>> ax.plot(xs, y3, label='Const (1/3 * Silverman)')
     |      >>> ax.legend()
     |      >>> plt.show()
     |  
     |  ssiillvveerrmmaann__ffaaccttoorr(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
    
    class rrvv__ccoonnttiinnuuoouuss(rv_generic)
     |  rv_continuous(momtype=1, a=None, b=None, xtol=1e-14, badvalue=None, name=None, longname=None, shapes=None, extradoc=None, seed=None)
     |  
     |  A generic continuous random variable class meant for subclassing.
     |  
     |  `rv_continuous` is a base class to construct specific distribution classes
     |  and instances for continuous random variables. It cannot be used
     |  directly as a distribution.
     |  
     |  Parameters
     |  ----------
     |  momtype : int, optional
     |      The type of generic moment calculation to use: 0 for pdf, 1 (default)
     |      for ppf.
     |  a : float, optional
     |      Lower bound of the support of the distribution, default is minus
     |      infinity.
     |  b : float, optional
     |      Upper bound of the support of the distribution, default is plus
     |      infinity.
     |  xtol : float, optional
     |      The tolerance for fixed point calculation for generic ppf.
     |  badvalue : float, optional
     |      The value in a result arrays that indicates a value that for which
     |      some argument restriction is violated, default is np.nan.
     |  name : str, optional
     |      The name of the instance. This string is used to construct the default
     |      example for distributions.
     |  longname : str, optional
     |      This string is used as part of the first line of the docstring returned
     |      when a subclass has no docstring of its own. Note: `longname` exists
     |      for backwards compatibility, do not use for new subclasses.
     |  shapes : str, optional
     |      The shape of the distribution. For example ``"m, n"`` for a
     |      distribution that takes two integers as the two shape arguments for all
     |      its methods. If not provided, shape parameters will be inferred from
     |      the signature of the private methods, ``_pdf`` and ``_cdf`` of the
     |      instance.
     |  extradoc :  str, optional, deprecated
     |      This string is used as the last part of the docstring returned when a
     |      subclass has no docstring of its own. Note: `extradoc` exists for
     |      backwards compatibility, do not use for new subclasses.
     |  seed : None or int or ``numpy.random.RandomState`` instance, optional
     |      This parameter defines the RandomState object to use for drawing
     |      random variates.
     |      If None (or np.random), the global np.random state is used.
     |      If integer, it is used to seed the local RandomState instance.
     |      Default is None.
     |  
     |  Methods
     |  -------
     |  rvs
     |  pdf
     |  logpdf
     |  cdf
     |  logcdf
     |  sf
     |  logsf
     |  ppf
     |  isf
     |  moment
     |  stats
     |  entropy
     |  expect
     |  median
     |  mean
     |  std
     |  var
     |  interval
     |  __call__
     |  fit
     |  fit_loc_scale
     |  nnlf
     |  
     |  Notes
     |  -----
     |  Public methods of an instance of a distribution class (e.g., ``pdf``,
     |  ``cdf``) check their arguments and pass valid arguments to private,
     |  computational methods (``_pdf``, ``_cdf``). For ``pdf(x)``, ``x`` is valid
     |  if it is within the support of a distribution, ``self.a <= x <= self.b``.
     |  Whether a shape parameter is valid is decided by an ``_argcheck`` method
     |  (which defaults to checking that its arguments are strictly positive.)
     |  
     |  **Subclassing**
     |  
     |  New random variables can be defined by subclassing the `rv_continuous` class
     |  and re-defining at least the ``_pdf`` or the ``_cdf`` method (normalized
     |  to location 0 and scale 1).
     |  
     |  If positive argument checking is not correct for your RV
     |  then you will also need to re-define the ``_argcheck`` method.
     |  
     |  Correct, but potentially slow defaults exist for the remaining
     |  methods but for speed and/or accuracy you can over-ride::
     |  
     |    _logpdf, _cdf, _logcdf, _ppf, _rvs, _isf, _sf, _logsf
     |  
     |  Rarely would you override ``_isf``, ``_sf`` or ``_logsf``, but you could.
     |  
     |  **Methods that can be overwritten by subclasses**
     |  ::
     |  
     |    _rvs
     |    _pdf
     |    _cdf
     |    _sf
     |    _ppf
     |    _isf
     |    _stats
     |    _munp
     |    _entropy
     |    _argcheck
     |  
     |  There are additional (internal and private) generic methods that can
     |  be useful for cross-checking and for debugging, but might work in all
     |  cases when directly called.
     |  
     |  A note on ``shapes``: subclasses need not specify them explicitly. In this
     |  case, `shapes` will be automatically deduced from the signatures of the
     |  overridden methods (`pdf`, `cdf` etc).
     |  If, for some reason, you prefer to avoid relying on introspection, you can
     |  specify ``shapes`` explicitly as an argument to the instance constructor.
     |  
     |  
     |  **Frozen Distributions**
     |  
     |  Normally, you must provide shape parameters (and, optionally, location and
     |  scale parameters to each call of a method of a distribution.
     |  
     |  Alternatively, the object may be called (as a function) to fix the shape,
     |  location, and scale parameters returning a "frozen" continuous RV object:
     |  
     |  rv = generic(<shape(s)>, loc=0, scale=1)
     |      frozen RV object with the same methods but holding the given shape,
     |      location, and scale fixed
     |  
     |  **Statistics**
     |  
     |  Statistics are computed using numerical integration by default.
     |  For speed you can redefine this using ``_stats``:
     |  
     |   - take shape parameters and return mu, mu2, g1, g2
     |   - If you can't compute one of these, return it as None
     |   - Can also be defined with a keyword argument ``moments``, which is a
     |     string composed of "m", "v", "s", and/or "k".
     |     Only the components appearing in string should be computed and
     |     returned in the order "m", "v", "s", or "k"  with missing values
     |     returned as None.
     |  
     |  Alternatively, you can override ``_munp``, which takes ``n`` and shape
     |  parameters and returns the n-th non-central moment of the distribution.
     |  
     |  Examples
     |  --------
     |  To create a new Gaussian distribution, we would do the following:
     |  
     |  >>> from scipy.stats import rv_continuous
     |  >>> class gaussian_gen(rv_continuous):
     |  ...     "Gaussian distribution"
     |  ...     def _pdf(self, x):
     |  ...         return np.exp(-x**2 / 2.) / np.sqrt(2.0 * np.pi)
     |  >>> gaussian = gaussian_gen(name='gaussian')
     |  
     |  ``scipy.stats`` distributions are *instances*, so here we subclass
     |  `rv_continuous` and create an instance. With this, we now have
     |  a fully functional distribution with all relevant methods automagically
     |  generated by the framework.
     |  
     |  Note that above we defined a standard normal distribution, with zero mean
     |  and unit variance. Shifting and scaling of the distribution can be done
     |  by using ``loc`` and ``scale`` parameters: ``gaussian.pdf(x, loc, scale)``
     |  essentially computes ``y = (x - loc) / scale`` and
     |  ``gaussian._pdf(y) / scale``.
     |  
     |  Method resolution order:
     |      rv_continuous
     |      rv_generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  ____iinniitt____(self, momtype=1, a=None, b=None, xtol=1e-14, badvalue=None, name=None, longname=None, shapes=None, extradoc=None, seed=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ccddff(self, x, *args, **kwds)
     |      Cumulative distribution function of the given RV.
     |      
     |      Parameters
     |      ----------
     |      x : array_like
     |          quantiles
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      cdf : ndarray
     |          Cumulative distribution function evaluated at `x`
     |  
     |  eexxppeecctt(self, func=None, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
     |      Calculate expected value of a function with respect to the
     |      distribution.
     |      
     |      The expected value of a function ``f(x)`` with respect to a
     |      distribution ``dist`` is defined as::
     |      
     |                  ubound
     |          E[x] = Integral(f(x) * dist.pdf(x))
     |                  lbound
     |      
     |      Parameters
     |      ----------
     |      func : callable, optional
     |          Function for which integral is calculated. Takes only one argument.
     |          The default is the identity mapping f(x) = x.
     |      args : tuple, optional
     |          Shape parameters of the distribution.
     |      loc : float, optional
     |          Location parameter (default=0).
     |      scale : float, optional
     |          Scale parameter (default=1).
     |      lb, ub : scalar, optional
     |          Lower and upper bound for integration. Default is set to the
     |          support of the distribution.
     |      conditional : bool, optional
     |          If True, the integral is corrected by the conditional probability
     |          of the integration interval.  The return value is the expectation
     |          of the function, conditional on being in the given interval.
     |          Default is False.
     |      
     |      Additional keyword arguments are passed to the integration routine.
     |      
     |      Returns
     |      -------
     |      expect : float
     |          The calculated expected value.
     |      
     |      Notes
     |      -----
     |      The integration behavior of this function is inherited from
     |      `integrate.quad`.
     |  
     |  ffiitt(self, data, *args, **kwds)
     |      Return MLEs for shape (if applicable), location, and scale
     |      parameters from data.
     |      
     |      MLE stands for Maximum Likelihood Estimate.  Starting estimates for
     |      the fit are given by input arguments; for any arguments not provided
     |      with starting estimates, ``self._fitstart(data)`` is called to generate
     |      such.
     |      
     |      One can hold some parameters fixed to specific values by passing in
     |      keyword arguments ``f0``, ``f1``, ..., ``fn`` (for shape parameters)
     |      and ``floc`` and ``fscale`` (for location and scale parameters,
     |      respectively).
     |      
     |      Parameters
     |      ----------
     |      data : array_like
     |          Data to use in calculating the MLEs.
     |      args : floats, optional
     |          Starting value(s) for any shape-characterizing arguments (those not
     |          provided will be determined by a call to ``_fitstart(data)``).
     |          No default value.
     |      kwds : floats, optional
     |          Starting values for the location and scale parameters; no default.
     |          Special keyword arguments are recognized as holding certain
     |          parameters fixed:
     |      
     |          - f0...fn : hold respective shape parameters fixed.
     |            Alternatively, shape parameters to fix can be specified by name.
     |            For example, if ``self.shapes == "a, b"``, ``fa``and ``fix_a``
     |            are equivalent to ``f0``, and ``fb`` and ``fix_b`` are
     |            equivalent to ``f1``.
     |      
     |          - floc : hold location parameter fixed to specified value.
     |      
     |          - fscale : hold scale parameter fixed to specified value.
     |      
     |          - optimizer : The optimizer to use.  The optimizer must take ``func``,
     |            and starting position as the first two arguments,
     |            plus ``args`` (for extra arguments to pass to the
     |            function to be optimized) and ``disp=0`` to suppress
     |            output as keyword arguments.
     |      
     |      Returns
     |      -------
     |      mle_tuple : tuple of floats
     |          MLEs for any shape parameters (if applicable), followed by those
     |          for location and scale. For most random variables, shape statistics
     |          will be returned, but there are exceptions (e.g. ``norm``).
     |      
     |      Notes
     |      -----
     |      This fit is computed by maximizing a log-likelihood function, with
     |      penalty applied for samples outside of range of the distribution. The
     |      returned answer is not guaranteed to be the globally optimal MLE, it
     |      may only be locally optimal, or the optimization may fail altogether.
     |      
     |      Examples
     |      --------
     |      
     |      Generate some data to fit: draw random variates from the `beta`
     |      distribution
     |      
     |      >>> from scipy.stats import beta
     |      >>> a, b = 1., 2.
     |      >>> x = beta.rvs(a, b, size=1000)
     |      
     |      Now we can fit all four parameters (``a``, ``b``, ``loc`` and ``scale``):
     |      
     |      >>> a1, b1, loc1, scale1 = beta.fit(x)
     |      
     |      We can also use some prior knowledge about the dataset: let's keep
     |      ``loc`` and ``scale`` fixed:
     |      
     |      >>> a1, b1, loc1, scale1 = beta.fit(x, floc=0, fscale=1)
     |      >>> loc1, scale1
     |      (0, 1)
     |      
     |      We can also keep shape parameters fixed by using ``f``-keywords. To
     |      keep the zero-th shape parameter ``a`` equal 1, use ``f0=1`` or,
     |      equivalently, ``fa=1``:
     |      
     |      >>> a1, b1, loc1, scale1 = beta.fit(x, fa=1, floc=0, fscale=1)
     |      >>> a1
     |      1
     |      
     |      Not all distributions return estimates for the shape parameters.
     |      ``norm`` for example just returns estimates for location and scale:
     |      
     |      >>> from scipy.stats import norm
     |      >>> x = norm.rvs(a, b, size=1000, random_state=123)
     |      >>> loc1, scale1 = norm.fit(x)
     |      >>> loc1, scale1
     |      (0.92087172783841631, 2.0015750750324668)
     |  
     |  ffiitt__lloocc__ssccaallee(self, data, *args)
     |      Estimate loc and scale parameters from data using 1st and 2nd moments.
     |      
     |      Parameters
     |      ----------
     |      data : array_like
     |          Data to fit.
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      
     |      Returns
     |      -------
     |      Lhat : float
     |          Estimated location parameter for the data.
     |      Shat : float
     |          Estimated scale parameter for the data.
     |  
     |  iissff(self, q, *args, **kwds)
     |      Inverse survival function (inverse of `sf`) at q of the given RV.
     |      
     |      Parameters
     |      ----------
     |      q : array_like
     |          upper tail probability
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      x : ndarray or scalar
     |          Quantile corresponding to the upper tail probability q.
     |  
     |  llooggccddff(self, x, *args, **kwds)
     |      Log of the cumulative distribution function at x of the given RV.
     |      
     |      Parameters
     |      ----------
     |      x : array_like
     |          quantiles
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      logcdf : array_like
     |          Log of the cumulative distribution function evaluated at x
     |  
     |  llooggppddff(self, x, *args, **kwds)
     |      Log of the probability density function at x of the given RV.
     |      
     |      This uses a more numerically accurate calculation if available.
     |      
     |      Parameters
     |      ----------
     |      x : array_like
     |          quantiles
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      logpdf : array_like
     |          Log of the probability density function evaluated at x
     |  
     |  llooggssff(self, x, *args, **kwds)
     |      Log of the survival function of the given RV.
     |      
     |      Returns the log of the "survival function," defined as (1 - `cdf`),
     |      evaluated at `x`.
     |      
     |      Parameters
     |      ----------
     |      x : array_like
     |          quantiles
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      logsf : ndarray
     |          Log of the survival function evaluated at `x`.
     |  
     |  nnnnllff(self, theta, x)
     |      Return negative loglikelihood function.
     |      
     |      Notes
     |      -----
     |      This is ``-sum(log pdf(x, theta), axis=0)`` where `theta` are the
     |      parameters (including loc and scale).
     |  
     |  ppddff(self, x, *args, **kwds)
     |      Probability density function at x of the given RV.
     |      
     |      Parameters
     |      ----------
     |      x : array_like
     |          quantiles
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      pdf : ndarray
     |          Probability density function evaluated at x
     |  
     |  ppppff(self, q, *args, **kwds)
     |      Percent point function (inverse of `cdf`) at q of the given RV.
     |      
     |      Parameters
     |      ----------
     |      q : array_like
     |          lower tail probability
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      x : array_like
     |          quantile corresponding to the lower tail probability q.
     |  
     |  ssff(self, x, *args, **kwds)
     |      Survival function (1 - `cdf`) at x of the given RV.
     |      
     |      Parameters
     |      ----------
     |      x : array_like
     |          quantiles
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      sf : array_like
     |          Survival function evaluated at x
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from rv_generic:
     |  
     |  ____ccaallll____(self, *args, **kwds)
     |      Freeze the distribution for the given arguments.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution.  Should include all
     |          the non-optional arguments, may include ``loc`` and ``scale``.
     |      
     |      Returns
     |      -------
     |      rv_frozen : rv_frozen instance
     |          The frozen distribution.
     |  
     |  ____ggeettssttaattee____(self)
     |  
     |  ____sseettssttaattee____(self, state)
     |  
     |  eennttrrooppyy(self, *args, **kwds)
     |      Differential entropy of the RV.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          Location parameter (default=0).
     |      scale : array_like, optional  (continuous distributions only).
     |          Scale parameter (default=1).
     |      
     |      Notes
     |      -----
     |      Entropy is defined base `e`:
     |      
     |      >>> drv = rv_discrete(values=((0, 1), (0.5, 0.5)))
     |      >>> np.allclose(drv.entropy(), np.log(2.0))
     |      True
     |  
     |  ffrreeeezzee(self, *args, **kwds)
     |      Freeze the distribution for the given arguments.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution.  Should include all
     |          the non-optional arguments, may include ``loc`` and ``scale``.
     |      
     |      Returns
     |      -------
     |      rv_frozen : rv_frozen instance
     |          The frozen distribution.
     |  
     |  iinntteerrvvaall(self, alpha, *args, **kwds)
     |      Confidence interval with equal areas around the median.
     |      
     |      Parameters
     |      ----------
     |      alpha : array_like of float
     |          Probability that an rv will be drawn from the returned range.
     |          Each value should be in the range [0, 1].
     |      arg1, arg2, ... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          location parameter, Default is 0.
     |      scale : array_like, optional
     |          scale parameter, Default is 1.
     |      
     |      Returns
     |      -------
     |      a, b : ndarray of float
     |          end-points of range that contain ``100 * alpha %`` of the rv's
     |          possible values.
     |  
     |  mmeeaann(self, *args, **kwds)
     |      Mean of the distribution.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      mean : float
     |          the mean of the distribution
     |  
     |  mmeeddiiaann(self, *args, **kwds)
     |      Median of the distribution.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          Location parameter, Default is 0.
     |      scale : array_like, optional
     |          Scale parameter, Default is 1.
     |      
     |      Returns
     |      -------
     |      median : float
     |          The median of the distribution.
     |      
     |      See Also
     |      --------
     |      stats.distributions.rv_discrete.ppf
     |          Inverse of the CDF
     |  
     |  mmoommeenntt(self, n, *args, **kwds)
     |      n-th order non-central moment of distribution.
     |      
     |      Parameters
     |      ----------
     |      n : int, n >= 1
     |          Order of moment.
     |      arg1, arg2, arg3,... : float
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |  
     |  rrvvss(self, *args, **kwds)
     |      Random variates of given type.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          Location parameter (default=0).
     |      scale : array_like, optional
     |          Scale parameter (default=1).
     |      size : int or tuple of ints, optional
     |          Defining number of random variates (default is 1).
     |      random_state : None or int or ``np.random.RandomState`` instance, optional
     |          If int or RandomState, use it for drawing the random variates.
     |          If None, rely on ``self.random_state``.
     |          Default is None.
     |      
     |      Returns
     |      -------
     |      rvs : ndarray or scalar
     |          Random variates of given `size`.
     |  
     |  ssttaattss(self, *args, **kwds)
     |      Some statistics of the given RV.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional (continuous RVs only)
     |          scale parameter (default=1)
     |      moments : str, optional
     |          composed of letters ['mvsk'] defining which moments to compute:
     |          'm' = mean,
     |          'v' = variance,
     |          's' = (Fisher's) skew,
     |          'k' = (Fisher's) kurtosis.
     |          (default is 'mv')
     |      
     |      Returns
     |      -------
     |      stats : sequence
     |          of requested moments.
     |  
     |  ssttdd(self, *args, **kwds)
     |      Standard deviation of the distribution.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      std : float
     |          standard deviation of the distribution
     |  
     |  vvaarr(self, *args, **kwds)
     |      Variance of the distribution.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      var : float
     |          the variance of the distribution
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from rv_generic:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  rraannddoomm__ssttaattee
     |      Get or set the RandomState object for generating random variates.
     |      
     |      This can be either None or an existing RandomState object.
     |      
     |      If None (or np.random), use the RandomState singleton used by np.random.
     |      If already a RandomState instance, use it.
     |      If an int, use a new RandomState instance seeded with seed.
    
    class rrvv__ddiissccrreettee(rv_generic)
     |  rv_discrete(a=0, b=inf, name=None, badvalue=None, moment_tol=1e-08, values=None, inc=1, longname=None, shapes=None, extradoc=None, seed=None)
     |  
     |  A generic discrete random variable class meant for subclassing.
     |  
     |  `rv_discrete` is a base class to construct specific distribution classes
     |  and instances for discrete random variables. It can also be used
     |  to construct an arbitrary distribution defined by a list of support
     |  points and corresponding probabilities.
     |  
     |  Parameters
     |  ----------
     |  a : float, optional
     |      Lower bound of the support of the distribution, default: 0
     |  b : float, optional
     |      Upper bound of the support of the distribution, default: plus infinity
     |  moment_tol : float, optional
     |      The tolerance for the generic calculation of moments.
     |  values : tuple of two array_like, optional
     |      ``(xk, pk)`` where ``xk`` are integers with non-zero
     |      probabilities ``pk``  with ``sum(pk) = 1``.
     |  inc : integer, optional
     |      Increment for the support of the distribution.
     |      Default is 1. (other values have not been tested)
     |  badvalue : float, optional
     |      The value in a result arrays that indicates a value that for which
     |      some argument restriction is violated, default is np.nan.
     |  name : str, optional
     |      The name of the instance. This string is used to construct the default
     |      example for distributions.
     |  longname : str, optional
     |      This string is used as part of the first line of the docstring returned
     |      when a subclass has no docstring of its own. Note: `longname` exists
     |      for backwards compatibility, do not use for new subclasses.
     |  shapes : str, optional
     |      The shape of the distribution. For example "m, n" for a distribution
     |      that takes two integers as the two shape arguments for all its methods
     |      If not provided, shape parameters will be inferred from
     |      the signatures of the private methods, ``_pmf`` and ``_cdf`` of
     |      the instance.
     |  extradoc :  str, optional
     |      This string is used as the last part of the docstring returned when a
     |      subclass has no docstring of its own. Note: `extradoc` exists for
     |      backwards compatibility, do not use for new subclasses.
     |  seed : None or int or ``numpy.random.RandomState`` instance, optional
     |      This parameter defines the RandomState object to use for drawing
     |      random variates.
     |      If None, the global np.random state is used.
     |      If integer, it is used to seed the local RandomState instance.
     |      Default is None.
     |  
     |  Methods
     |  -------
     |  rvs
     |  pmf
     |  logpmf
     |  cdf
     |  logcdf
     |  sf
     |  logsf
     |  ppf
     |  isf
     |  moment
     |  stats
     |  entropy
     |  expect
     |  median
     |  mean
     |  std
     |  var
     |  interval
     |  __call__
     |  
     |  
     |  Notes
     |  -----
     |  
     |  This class is similar to `rv_continuous`. Whether a shape parameter is
     |  valid is decided by an ``_argcheck`` method (which defaults to checking
     |  that its arguments are strictly positive.)
     |  The main differences are:
     |  
     |  - the support of the distribution is a set of integers
     |  - instead of the probability density function, ``pdf`` (and the
     |    corresponding private ``_pdf``), this class defines the
     |    *probability mass function*, `pmf` (and the corresponding
     |    private ``_pmf``.)
     |  - scale parameter is not defined.
     |  
     |  To create a new discrete distribution, we would do the following:
     |  
     |  >>> from scipy.stats import rv_discrete
     |  >>> class poisson_gen(rv_discrete):
     |  ...     "Poisson distribution"
     |  ...     def _pmf(self, k, mu):
     |  ...         return exp(-mu) * mu**k / factorial(k)
     |  
     |  and create an instance::
     |  
     |  >>> poisson = poisson_gen(name="poisson")
     |  
     |  Note that above we defined the Poisson distribution in the standard form.
     |  Shifting the distribution can be done by providing the ``loc`` parameter
     |  to the methods of the instance. For example, ``poisson.pmf(x, mu, loc)``
     |  delegates the work to ``poisson._pmf(x-loc, mu)``.
     |  
     |  **Discrete distributions from a list of probabilities**
     |  
     |  Alternatively, you can construct an arbitrary discrete rv defined
     |  on a finite set of values ``xk`` with ``Prob{X=xk} = pk`` by using the
     |  ``values`` keyword argument to the `rv_discrete` constructor.
     |  
     |  Examples
     |  --------
     |  
     |  Custom made discrete distribution:
     |  
     |  >>> from scipy import stats
     |  >>> xk = np.arange(7)
     |  >>> pk = (0.1, 0.2, 0.3, 0.1, 0.1, 0.0, 0.2)
     |  >>> custm = stats.rv_discrete(name='custm', values=(xk, pk))
     |  >>>
     |  >>> import matplotlib.pyplot as plt
     |  >>> fig, ax = plt.subplots(1, 1)
     |  >>> ax.plot(xk, custm.pmf(xk), 'ro', ms=12, mec='r')
     |  >>> ax.vlines(xk, 0, custm.pmf(xk), colors='r', lw=4)
     |  >>> plt.show()
     |  
     |  Random number generation:
     |  
     |  >>> R = custm.rvs(size=100)
     |  
     |  Method resolution order:
     |      rv_discrete
     |      rv_generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  ____iinniitt____(self, a=0, b=inf, name=None, badvalue=None, moment_tol=1e-08, values=None, inc=1, longname=None, shapes=None, extradoc=None, seed=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ccddff(self, k, *args, **kwds)
     |      Cumulative distribution function of the given RV.
     |      
     |      Parameters
     |      ----------
     |      k : array_like, int
     |          Quantiles.
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          Location parameter (default=0).
     |      
     |      Returns
     |      -------
     |      cdf : ndarray
     |          Cumulative distribution function evaluated at `k`.
     |  
     |  eexxppeecctt(self, func=None, args=(), loc=0, lb=None, ub=None, conditional=False, maxcount=1000, tolerance=1e-10, chunksize=32)
     |      Calculate expected value of a function with respect to the distribution
     |      for discrete distribution.
     |      
     |      Parameters
     |      ----------
     |      func : callable, optional
     |          Function for which the expectation value is calculated.
     |          Takes only one argument.
     |          The default is the identity mapping f(k) = k.
     |      args : tuple, optional
     |          Shape parameters of the distribution.
     |      loc : float, optional
     |          Location parameter.
     |          Default is 0.
     |      lb, ub : int, optional
     |          Lower and upper bound for the summation, default is set to the
     |          support of the distribution, inclusive (``ul <= k <= ub``).
     |      conditional : bool, optional
     |          If true then the expectation is corrected by the conditional
     |          probability of the summation interval. The return value is the
     |          expectation of the function, `func`, conditional on being in
     |          the given interval (k such that ``ul <= k <= ub``).
     |          Default is False.
     |      maxcount : int, optional
     |          Maximal number of terms to evaluate (to avoid an endless loop for
     |          an infinite sum). Default is 1000.
     |      tolerance : float, optional
     |          Absolute tolerance for the summation. Default is 1e-10.
     |      chunksize : int, optional
     |          Iterate over the support of a distributions in chunks of this size.
     |          Default is 32.
     |      
     |      Returns
     |      -------
     |      expect : float
     |          Expected value.
     |      
     |      Notes
     |      -----
     |      For heavy-tailed distributions, the expected value may or may not exist,
     |      depending on the function, `func`. If it does exist, but the sum converges
     |      slowly, the accuracy of the result may be rather low. For instance, for
     |      ``zipf(4)``, accuracy for mean, variance in example is only 1e-5.
     |      increasing `maxcount` and/or `chunksize` may improve the result, but may also
     |      make zipf very slow.
     |      
     |      The function is not vectorized.
     |  
     |  iissff(self, q, *args, **kwds)
     |      Inverse survival function (inverse of `sf`) at q of the given RV.
     |      
     |      Parameters
     |      ----------
     |      q : array_like
     |          Upper tail probability.
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          Location parameter (default=0).
     |      
     |      Returns
     |      -------
     |      k : ndarray or scalar
     |          Quantile corresponding to the upper tail probability, q.
     |  
     |  llooggccddff(self, k, *args, **kwds)
     |      Log of the cumulative distribution function at k of the given RV.
     |      
     |      Parameters
     |      ----------
     |      k : array_like, int
     |          Quantiles.
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          Location parameter (default=0).
     |      
     |      Returns
     |      -------
     |      logcdf : array_like
     |          Log of the cumulative distribution function evaluated at k.
     |  
     |  llooggppmmff(self, k, *args, **kwds)
     |      Log of the probability mass function at k of the given RV.
     |      
     |      Parameters
     |      ----------
     |      k : array_like
     |          Quantiles.
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          Location parameter. Default is 0.
     |      
     |      Returns
     |      -------
     |      logpmf : array_like
     |          Log of the probability mass function evaluated at k.
     |  
     |  llooggssff(self, k, *args, **kwds)
     |      Log of the survival function of the given RV.
     |      
     |      Returns the log of the "survival function," defined as 1 - `cdf`,
     |      evaluated at `k`.
     |      
     |      Parameters
     |      ----------
     |      k : array_like
     |          Quantiles.
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          Location parameter (default=0).
     |      
     |      Returns
     |      -------
     |      logsf : ndarray
     |          Log of the survival function evaluated at `k`.
     |  
     |  ppmmff(self, k, *args, **kwds)
     |      Probability mass function at k of the given RV.
     |      
     |      Parameters
     |      ----------
     |      k : array_like
     |          Quantiles.
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          Location parameter (default=0).
     |      
     |      Returns
     |      -------
     |      pmf : array_like
     |          Probability mass function evaluated at k
     |  
     |  ppppff(self, q, *args, **kwds)
     |      Percent point function (inverse of `cdf`) at q of the given RV.
     |      
     |      Parameters
     |      ----------
     |      q : array_like
     |          Lower tail probability.
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          Location parameter (default=0).
     |      
     |      Returns
     |      -------
     |      k : array_like
     |          Quantile corresponding to the lower tail probability, q.
     |  
     |  rrvvss(self, *args, **kwargs)
     |      Random variates of given type.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          Location parameter (default=0).
     |      size : int or tuple of ints, optional
     |          Defining number of random variates (Default is 1).  Note that `size`
     |          has to be given as keyword, not as positional argument.
     |      random_state : None or int or ``np.random.RandomState`` instance, optional
     |          If int or RandomState, use it for drawing the random variates.
     |          If None, rely on ``self.random_state``.
     |          Default is None.
     |      
     |      Returns
     |      -------
     |      rvs : ndarray or scalar
     |          Random variates of given `size`.
     |  
     |  ssff(self, k, *args, **kwds)
     |      Survival function (1 - `cdf`) at k of the given RV.
     |      
     |      Parameters
     |      ----------
     |      k : array_like
     |          Quantiles.
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          Location parameter (default=0).
     |      
     |      Returns
     |      -------
     |      sf : array_like
     |          Survival function evaluated at k.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  ____nneeww____(cls, a=0, b=inf, name=None, badvalue=None, moment_tol=1e-08, values=None, inc=1, longname=None, shapes=None, extradoc=None, seed=None)
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from rv_generic:
     |  
     |  ____ccaallll____(self, *args, **kwds)
     |      Freeze the distribution for the given arguments.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution.  Should include all
     |          the non-optional arguments, may include ``loc`` and ``scale``.
     |      
     |      Returns
     |      -------
     |      rv_frozen : rv_frozen instance
     |          The frozen distribution.
     |  
     |  ____ggeettssttaattee____(self)
     |  
     |  ____sseettssttaattee____(self, state)
     |  
     |  eennttrrooppyy(self, *args, **kwds)
     |      Differential entropy of the RV.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          Location parameter (default=0).
     |      scale : array_like, optional  (continuous distributions only).
     |          Scale parameter (default=1).
     |      
     |      Notes
     |      -----
     |      Entropy is defined base `e`:
     |      
     |      >>> drv = rv_discrete(values=((0, 1), (0.5, 0.5)))
     |      >>> np.allclose(drv.entropy(), np.log(2.0))
     |      True
     |  
     |  ffrreeeezzee(self, *args, **kwds)
     |      Freeze the distribution for the given arguments.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution.  Should include all
     |          the non-optional arguments, may include ``loc`` and ``scale``.
     |      
     |      Returns
     |      -------
     |      rv_frozen : rv_frozen instance
     |          The frozen distribution.
     |  
     |  iinntteerrvvaall(self, alpha, *args, **kwds)
     |      Confidence interval with equal areas around the median.
     |      
     |      Parameters
     |      ----------
     |      alpha : array_like of float
     |          Probability that an rv will be drawn from the returned range.
     |          Each value should be in the range [0, 1].
     |      arg1, arg2, ... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          location parameter, Default is 0.
     |      scale : array_like, optional
     |          scale parameter, Default is 1.
     |      
     |      Returns
     |      -------
     |      a, b : ndarray of float
     |          end-points of range that contain ``100 * alpha %`` of the rv's
     |          possible values.
     |  
     |  mmeeaann(self, *args, **kwds)
     |      Mean of the distribution.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      mean : float
     |          the mean of the distribution
     |  
     |  mmeeddiiaann(self, *args, **kwds)
     |      Median of the distribution.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          Location parameter, Default is 0.
     |      scale : array_like, optional
     |          Scale parameter, Default is 1.
     |      
     |      Returns
     |      -------
     |      median : float
     |          The median of the distribution.
     |      
     |      See Also
     |      --------
     |      stats.distributions.rv_discrete.ppf
     |          Inverse of the CDF
     |  
     |  mmoommeenntt(self, n, *args, **kwds)
     |      n-th order non-central moment of distribution.
     |      
     |      Parameters
     |      ----------
     |      n : int, n >= 1
     |          Order of moment.
     |      arg1, arg2, arg3,... : float
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |  
     |  ssttaattss(self, *args, **kwds)
     |      Some statistics of the given RV.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional (continuous RVs only)
     |          scale parameter (default=1)
     |      moments : str, optional
     |          composed of letters ['mvsk'] defining which moments to compute:
     |          'm' = mean,
     |          'v' = variance,
     |          's' = (Fisher's) skew,
     |          'k' = (Fisher's) kurtosis.
     |          (default is 'mv')
     |      
     |      Returns
     |      -------
     |      stats : sequence
     |          of requested moments.
     |  
     |  ssttdd(self, *args, **kwds)
     |      Standard deviation of the distribution.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      std : float
     |          standard deviation of the distribution
     |  
     |  vvaarr(self, *args, **kwds)
     |      Variance of the distribution.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      var : float
     |          the variance of the distribution
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from rv_generic:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  rraannddoomm__ssttaattee
     |      Get or set the RandomState object for generating random variates.
     |      
     |      This can be either None or an existing RandomState object.
     |      
     |      If None (or np.random), use the RandomState singleton used by np.random.
     |      If already a RandomState instance, use it.
     |      If an int, use a new RandomState instance seeded with seed.
    
    class rrvv__hhiissttooggrraamm(scipy.stats._distn_infrastructure.rv_continuous)
     |  rv_histogram(histogram, *args, **kwargs)
     |  
     |  Generates a distribution given by a histogram.
     |  This is useful to generate a template distribution from a binned
     |  datasample.
     |  
     |  As a subclass of the `rv_continuous` class, `rv_histogram` inherits from it
     |  a collection of generic methods (see `rv_continuous` for the full list),
     |  and implements them based on the properties of the provided binned
     |  datasample.
     |  
     |  Parameters
     |  ----------
     |  histogram : tuple of array_like
     |    Tuple containing two array_like objects
     |    The first containing the content of n bins
     |    The second containing the (n+1) bin boundaries
     |    In particular the return value np.histogram is accepted
     |  
     |  Notes
     |  -----
     |  There are no additional shape parameters except for the loc and scale.
     |  The pdf is defined as a stepwise function from the provided histogram
     |  The cdf is a linear interpolation of the pdf.
     |  
     |  .. versionadded:: 0.19.0
     |  
     |  Examples
     |  --------
     |  
     |  Create a scipy.stats distribution from a numpy histogram
     |  
     |  >>> import scipy.stats
     |  >>> import numpy as np
     |  >>> data = scipy.stats.norm.rvs(size=100000, loc=0, scale=1.5, random_state=123)
     |  >>> hist = np.histogram(data, bins=100)
     |  >>> hist_dist = scipy.stats.rv_histogram(hist)
     |  
     |  Behaves like an ordinary scipy rv_continuous distribution
     |  
     |  >>> hist_dist.pdf(1.0)
     |  0.20538577847618705
     |  >>> hist_dist.cdf(2.0)
     |  0.90818568543056499
     |  
     |  PDF is zero above (below) the highest (lowest) bin of the histogram,
     |  defined by the max (min) of the original dataset
     |  
     |  >>> hist_dist.pdf(np.max(data))
     |  0.0
     |  >>> hist_dist.cdf(np.max(data))
     |  1.0
     |  >>> hist_dist.pdf(np.min(data))
     |  7.7591907244498314e-05
     |  >>> hist_dist.cdf(np.min(data))
     |  0.0
     |  
     |  PDF and CDF follow the histogram
     |  
     |  >>> import matplotlib.pyplot as plt
     |  >>> X = np.linspace(-5.0, 5.0, 100)
     |  >>> plt.title("PDF from Template")
     |  >>> plt.hist(data, density=True, bins=100)
     |  >>> plt.plot(X, hist_dist.pdf(X), label='PDF')
     |  >>> plt.plot(X, hist_dist.cdf(X), label='CDF')
     |  >>> plt.show()
     |  
     |  Method resolution order:
     |      rv_histogram
     |      scipy.stats._distn_infrastructure.rv_continuous
     |      scipy.stats._distn_infrastructure.rv_generic
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  ____iinniitt____(self, histogram, *args, **kwargs)
     |      Create a new distribution using the given histogram
     |      
     |      Parameters
     |      ----------
     |      histogram : tuple of array_like
     |        Tuple containing two array_like objects
     |        The first containing the content of n bins
     |        The second containing the (n+1) bin boundaries
     |        In particular the return value np.histogram is accepted
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from scipy.stats._distn_infrastructure.rv_continuous:
     |  
     |  ccddff(self, x, *args, **kwds)
     |      Cumulative distribution function of the given RV.
     |      
     |      Parameters
     |      ----------
     |      x : array_like
     |          quantiles
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      cdf : ndarray
     |          Cumulative distribution function evaluated at `x`
     |  
     |  eexxppeecctt(self, func=None, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)
     |      Calculate expected value of a function with respect to the
     |      distribution.
     |      
     |      The expected value of a function ``f(x)`` with respect to a
     |      distribution ``dist`` is defined as::
     |      
     |                  ubound
     |          E[x] = Integral(f(x) * dist.pdf(x))
     |                  lbound
     |      
     |      Parameters
     |      ----------
     |      func : callable, optional
     |          Function for which integral is calculated. Takes only one argument.
     |          The default is the identity mapping f(x) = x.
     |      args : tuple, optional
     |          Shape parameters of the distribution.
     |      loc : float, optional
     |          Location parameter (default=0).
     |      scale : float, optional
     |          Scale parameter (default=1).
     |      lb, ub : scalar, optional
     |          Lower and upper bound for integration. Default is set to the
     |          support of the distribution.
     |      conditional : bool, optional
     |          If True, the integral is corrected by the conditional probability
     |          of the integration interval.  The return value is the expectation
     |          of the function, conditional on being in the given interval.
     |          Default is False.
     |      
     |      Additional keyword arguments are passed to the integration routine.
     |      
     |      Returns
     |      -------
     |      expect : float
     |          The calculated expected value.
     |      
     |      Notes
     |      -----
     |      The integration behavior of this function is inherited from
     |      `integrate.quad`.
     |  
     |  ffiitt(self, data, *args, **kwds)
     |      Return MLEs for shape (if applicable), location, and scale
     |      parameters from data.
     |      
     |      MLE stands for Maximum Likelihood Estimate.  Starting estimates for
     |      the fit are given by input arguments; for any arguments not provided
     |      with starting estimates, ``self._fitstart(data)`` is called to generate
     |      such.
     |      
     |      One can hold some parameters fixed to specific values by passing in
     |      keyword arguments ``f0``, ``f1``, ..., ``fn`` (for shape parameters)
     |      and ``floc`` and ``fscale`` (for location and scale parameters,
     |      respectively).
     |      
     |      Parameters
     |      ----------
     |      data : array_like
     |          Data to use in calculating the MLEs.
     |      args : floats, optional
     |          Starting value(s) for any shape-characterizing arguments (those not
     |          provided will be determined by a call to ``_fitstart(data)``).
     |          No default value.
     |      kwds : floats, optional
     |          Starting values for the location and scale parameters; no default.
     |          Special keyword arguments are recognized as holding certain
     |          parameters fixed:
     |      
     |          - f0...fn : hold respective shape parameters fixed.
     |            Alternatively, shape parameters to fix can be specified by name.
     |            For example, if ``self.shapes == "a, b"``, ``fa``and ``fix_a``
     |            are equivalent to ``f0``, and ``fb`` and ``fix_b`` are
     |            equivalent to ``f1``.
     |      
     |          - floc : hold location parameter fixed to specified value.
     |      
     |          - fscale : hold scale parameter fixed to specified value.
     |      
     |          - optimizer : The optimizer to use.  The optimizer must take ``func``,
     |            and starting position as the first two arguments,
     |            plus ``args`` (for extra arguments to pass to the
     |            function to be optimized) and ``disp=0`` to suppress
     |            output as keyword arguments.
     |      
     |      Returns
     |      -------
     |      mle_tuple : tuple of floats
     |          MLEs for any shape parameters (if applicable), followed by those
     |          for location and scale. For most random variables, shape statistics
     |          will be returned, but there are exceptions (e.g. ``norm``).
     |      
     |      Notes
     |      -----
     |      This fit is computed by maximizing a log-likelihood function, with
     |      penalty applied for samples outside of range of the distribution. The
     |      returned answer is not guaranteed to be the globally optimal MLE, it
     |      may only be locally optimal, or the optimization may fail altogether.
     |      
     |      Examples
     |      --------
     |      
     |      Generate some data to fit: draw random variates from the `beta`
     |      distribution
     |      
     |      >>> from scipy.stats import beta
     |      >>> a, b = 1., 2.
     |      >>> x = beta.rvs(a, b, size=1000)
     |      
     |      Now we can fit all four parameters (``a``, ``b``, ``loc`` and ``scale``):
     |      
     |      >>> a1, b1, loc1, scale1 = beta.fit(x)
     |      
     |      We can also use some prior knowledge about the dataset: let's keep
     |      ``loc`` and ``scale`` fixed:
     |      
     |      >>> a1, b1, loc1, scale1 = beta.fit(x, floc=0, fscale=1)
     |      >>> loc1, scale1
     |      (0, 1)
     |      
     |      We can also keep shape parameters fixed by using ``f``-keywords. To
     |      keep the zero-th shape parameter ``a`` equal 1, use ``f0=1`` or,
     |      equivalently, ``fa=1``:
     |      
     |      >>> a1, b1, loc1, scale1 = beta.fit(x, fa=1, floc=0, fscale=1)
     |      >>> a1
     |      1
     |      
     |      Not all distributions return estimates for the shape parameters.
     |      ``norm`` for example just returns estimates for location and scale:
     |      
     |      >>> from scipy.stats import norm
     |      >>> x = norm.rvs(a, b, size=1000, random_state=123)
     |      >>> loc1, scale1 = norm.fit(x)
     |      >>> loc1, scale1
     |      (0.92087172783841631, 2.0015750750324668)
     |  
     |  ffiitt__lloocc__ssccaallee(self, data, *args)
     |      Estimate loc and scale parameters from data using 1st and 2nd moments.
     |      
     |      Parameters
     |      ----------
     |      data : array_like
     |          Data to fit.
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      
     |      Returns
     |      -------
     |      Lhat : float
     |          Estimated location parameter for the data.
     |      Shat : float
     |          Estimated scale parameter for the data.
     |  
     |  iissff(self, q, *args, **kwds)
     |      Inverse survival function (inverse of `sf`) at q of the given RV.
     |      
     |      Parameters
     |      ----------
     |      q : array_like
     |          upper tail probability
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      x : ndarray or scalar
     |          Quantile corresponding to the upper tail probability q.
     |  
     |  llooggccddff(self, x, *args, **kwds)
     |      Log of the cumulative distribution function at x of the given RV.
     |      
     |      Parameters
     |      ----------
     |      x : array_like
     |          quantiles
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      logcdf : array_like
     |          Log of the cumulative distribution function evaluated at x
     |  
     |  llooggppddff(self, x, *args, **kwds)
     |      Log of the probability density function at x of the given RV.
     |      
     |      This uses a more numerically accurate calculation if available.
     |      
     |      Parameters
     |      ----------
     |      x : array_like
     |          quantiles
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      logpdf : array_like
     |          Log of the probability density function evaluated at x
     |  
     |  llooggssff(self, x, *args, **kwds)
     |      Log of the survival function of the given RV.
     |      
     |      Returns the log of the "survival function," defined as (1 - `cdf`),
     |      evaluated at `x`.
     |      
     |      Parameters
     |      ----------
     |      x : array_like
     |          quantiles
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      logsf : ndarray
     |          Log of the survival function evaluated at `x`.
     |  
     |  nnnnllff(self, theta, x)
     |      Return negative loglikelihood function.
     |      
     |      Notes
     |      -----
     |      This is ``-sum(log pdf(x, theta), axis=0)`` where `theta` are the
     |      parameters (including loc and scale).
     |  
     |  ppddff(self, x, *args, **kwds)
     |      Probability density function at x of the given RV.
     |      
     |      Parameters
     |      ----------
     |      x : array_like
     |          quantiles
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      pdf : ndarray
     |          Probability density function evaluated at x
     |  
     |  ppppff(self, q, *args, **kwds)
     |      Percent point function (inverse of `cdf`) at q of the given RV.
     |      
     |      Parameters
     |      ----------
     |      q : array_like
     |          lower tail probability
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      x : array_like
     |          quantile corresponding to the lower tail probability q.
     |  
     |  ssff(self, x, *args, **kwds)
     |      Survival function (1 - `cdf`) at x of the given RV.
     |      
     |      Parameters
     |      ----------
     |      x : array_like
     |          quantiles
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      sf : array_like
     |          Survival function evaluated at x
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from scipy.stats._distn_infrastructure.rv_generic:
     |  
     |  ____ccaallll____(self, *args, **kwds)
     |      Freeze the distribution for the given arguments.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution.  Should include all
     |          the non-optional arguments, may include ``loc`` and ``scale``.
     |      
     |      Returns
     |      -------
     |      rv_frozen : rv_frozen instance
     |          The frozen distribution.
     |  
     |  ____ggeettssttaattee____(self)
     |  
     |  ____sseettssttaattee____(self, state)
     |  
     |  eennttrrooppyy(self, *args, **kwds)
     |      Differential entropy of the RV.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          Location parameter (default=0).
     |      scale : array_like, optional  (continuous distributions only).
     |          Scale parameter (default=1).
     |      
     |      Notes
     |      -----
     |      Entropy is defined base `e`:
     |      
     |      >>> drv = rv_discrete(values=((0, 1), (0.5, 0.5)))
     |      >>> np.allclose(drv.entropy(), np.log(2.0))
     |      True
     |  
     |  ffrreeeezzee(self, *args, **kwds)
     |      Freeze the distribution for the given arguments.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution.  Should include all
     |          the non-optional arguments, may include ``loc`` and ``scale``.
     |      
     |      Returns
     |      -------
     |      rv_frozen : rv_frozen instance
     |          The frozen distribution.
     |  
     |  iinntteerrvvaall(self, alpha, *args, **kwds)
     |      Confidence interval with equal areas around the median.
     |      
     |      Parameters
     |      ----------
     |      alpha : array_like of float
     |          Probability that an rv will be drawn from the returned range.
     |          Each value should be in the range [0, 1].
     |      arg1, arg2, ... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          location parameter, Default is 0.
     |      scale : array_like, optional
     |          scale parameter, Default is 1.
     |      
     |      Returns
     |      -------
     |      a, b : ndarray of float
     |          end-points of range that contain ``100 * alpha %`` of the rv's
     |          possible values.
     |  
     |  mmeeaann(self, *args, **kwds)
     |      Mean of the distribution.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      mean : float
     |          the mean of the distribution
     |  
     |  mmeeddiiaann(self, *args, **kwds)
     |      Median of the distribution.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          Location parameter, Default is 0.
     |      scale : array_like, optional
     |          Scale parameter, Default is 1.
     |      
     |      Returns
     |      -------
     |      median : float
     |          The median of the distribution.
     |      
     |      See Also
     |      --------
     |      stats.distributions.rv_discrete.ppf
     |          Inverse of the CDF
     |  
     |  mmoommeenntt(self, n, *args, **kwds)
     |      n-th order non-central moment of distribution.
     |      
     |      Parameters
     |      ----------
     |      n : int, n >= 1
     |          Order of moment.
     |      arg1, arg2, arg3,... : float
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |  
     |  rrvvss(self, *args, **kwds)
     |      Random variates of given type.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information).
     |      loc : array_like, optional
     |          Location parameter (default=0).
     |      scale : array_like, optional
     |          Scale parameter (default=1).
     |      size : int or tuple of ints, optional
     |          Defining number of random variates (default is 1).
     |      random_state : None or int or ``np.random.RandomState`` instance, optional
     |          If int or RandomState, use it for drawing the random variates.
     |          If None, rely on ``self.random_state``.
     |          Default is None.
     |      
     |      Returns
     |      -------
     |      rvs : ndarray or scalar
     |          Random variates of given `size`.
     |  
     |  ssttaattss(self, *args, **kwds)
     |      Some statistics of the given RV.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional (continuous RVs only)
     |          scale parameter (default=1)
     |      moments : str, optional
     |          composed of letters ['mvsk'] defining which moments to compute:
     |          'm' = mean,
     |          'v' = variance,
     |          's' = (Fisher's) skew,
     |          'k' = (Fisher's) kurtosis.
     |          (default is 'mv')
     |      
     |      Returns
     |      -------
     |      stats : sequence
     |          of requested moments.
     |  
     |  ssttdd(self, *args, **kwds)
     |      Standard deviation of the distribution.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      std : float
     |          standard deviation of the distribution
     |  
     |  vvaarr(self, *args, **kwds)
     |      Variance of the distribution.
     |      
     |      Parameters
     |      ----------
     |      arg1, arg2, arg3,... : array_like
     |          The shape parameter(s) for the distribution (see docstring of the
     |          instance object for more information)
     |      loc : array_like, optional
     |          location parameter (default=0)
     |      scale : array_like, optional
     |          scale parameter (default=1)
     |      
     |      Returns
     |      -------
     |      var : float
     |          the variance of the distribution
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from scipy.stats._distn_infrastructure.rv_generic:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  rraannddoomm__ssttaattee
     |      Get or set the RandomState object for generating random variates.
     |      
     |      This can be either None or an existing RandomState object.
     |      
     |      If None (or np.random), use the RandomState singleton used by np.random.
     |      If already a RandomState instance, use it.
     |      If an int, use a new RandomState instance seeded with seed.

FFUUNNCCTTIIOONNSS
    aannddeerrssoonn(x, dist='norm')
        Anderson-Darling test for data coming from a particular distribution
        
        The Anderson-Darling tests the null hypothesis that a sample is
        drawn from a population that follows a particular distribution.
        For the Anderson-Darling test, the critical values depend on
        which distribution is being tested against.  This function works
        for normal, exponential, logistic, or Gumbel (Extreme Value
        Type I) distributions.
        
        Parameters
        ----------
        x : array_like
            array of sample data
        dist : {'norm','expon','logistic','gumbel','gumbel_l', gumbel_r',
            'extreme1'}, optional
            the type of distribution to test against.  The default is 'norm'
            and 'extreme1', 'gumbel_l' and 'gumbel' are synonyms.
        
        Returns
        -------
        statistic : float
            The Anderson-Darling test statistic
        critical_values : list
            The critical values for this distribution
        significance_level : list
            The significance levels for the corresponding critical values
            in percents.  The function returns critical values for a
            differing set of significance levels depending on the
            distribution that is being tested against.
        
        See Also
        --------
        kstest : The Kolmogorov-Smirnov test for goodness-of-fit.
        
        Notes
        -----
        Critical values provided are for the following significance levels:
        
        normal/exponenential
            15%, 10%, 5%, 2.5%, 1%
        logistic
            25%, 10%, 5%, 2.5%, 1%, 0.5%
        Gumbel
            25%, 10%, 5%, 2.5%, 1%
        
        If the returned statistic is larger than these critical values then
        for the corresponding significance level, the null hypothesis that
        the data come from the chosen distribution can be rejected.
        The returned statistic is referred to as 'A2' in the references.
        
        References
        ----------
        .. [1] http://www.itl.nist.gov/div898/handbook/prc/section2/prc213.htm
        .. [2] Stephens, M. A. (1974). EDF Statistics for Goodness of Fit and
               Some Comparisons, Journal of the American Statistical Association,
               Vol. 69, pp. 730-737.
        .. [3] Stephens, M. A. (1976). Asymptotic Results for Goodness-of-Fit
               Statistics with Unknown Parameters, Annals of Statistics, Vol. 4,
               pp. 357-369.
        .. [4] Stephens, M. A. (1977). Goodness of Fit for the Extreme Value
               Distribution, Biometrika, Vol. 64, pp. 583-588.
        .. [5] Stephens, M. A. (1977). Goodness of Fit with Special Reference
               to Tests for Exponentiality , Technical Report No. 262,
               Department of Statistics, Stanford University, Stanford, CA.
        .. [6] Stephens, M. A. (1979). Tests of Fit for the Logistic Distribution
               Based on the Empirical Distribution Function, Biometrika, Vol. 66,
               pp. 591-595.
    
    aannddeerrssoonn__kkssaammpp(samples, midrank=True)
        The Anderson-Darling test for k-samples.
        
        The k-sample Anderson-Darling test is a modification of the
        one-sample Anderson-Darling test. It tests the null hypothesis
        that k-samples are drawn from the same population without having
        to specify the distribution function of that population. The
        critical values depend on the number of samples.
        
        Parameters
        ----------
        samples : sequence of 1-D array_like
            Array of sample data in arrays.
        midrank : bool, optional
            Type of Anderson-Darling test which is computed. Default
            (True) is the midrank test applicable to continuous and
            discrete populations. If False, the right side empirical
            distribution is used.
        
        Returns
        -------
        statistic : float
            Normalized k-sample Anderson-Darling test statistic.
        critical_values : array
            The critical values for significance levels 25%, 10%, 5%, 2.5%, 1%.
        significance_level : float
            An approximate significance level at which the null hypothesis for the
            provided samples can be rejected.
        
        Raises
        ------
        ValueError
            If less than 2 samples are provided, a sample is empty, or no
            distinct observations are in the samples.
        
        See Also
        --------
        ks_2samp : 2 sample Kolmogorov-Smirnov test
        anderson : 1 sample Anderson-Darling test
        
        Notes
        -----
        [1]_ Defines three versions of the k-sample Anderson-Darling test:
        one for continuous distributions and two for discrete
        distributions, in which ties between samples may occur. The
        default of this routine is to compute the version based on the
        midrank empirical distribution function. This test is applicable
        to continuous and discrete data. If midrank is set to False, the
        right side empirical distribution is used for a test for discrete
        data. According to [1]_, the two discrete test statistics differ
        only slightly if a few collisions due to round-off errors occur in
        the test not adjusted for ties between samples.
        
        .. versionadded:: 0.14.0
        
        References
        ----------
        .. [1] Scholz, F. W and Stephens, M. A. (1987), K-Sample
               Anderson-Darling Tests, Journal of the American Statistical
               Association, Vol. 82, pp. 918-924.
        
        Examples
        --------
        >>> from scipy import stats
        >>> np.random.seed(314159)
        
        The null hypothesis that the two random samples come from the same
        distribution can be rejected at the 5% level because the returned
        test value is greater than the critical value for 5% (1.961) but
        not at the 2.5% level. The interpolation gives an approximate
        significance level of 3.1%:
        
        >>> stats.anderson_ksamp([np.random.normal(size=50),
        ... np.random.normal(loc=0.5, size=30)])
        (2.4615796189876105,
          array([ 0.325,  1.226,  1.961,  2.718,  3.752]),
          0.03134990135800783)
        
        
        The null hypothesis cannot be rejected for three samples from an
        identical distribution. The approximate p-value (87%) has to be
        computed by extrapolation and may not be very accurate:
        
        >>> stats.anderson_ksamp([np.random.normal(size=50),
        ... np.random.normal(size=30), np.random.normal(size=20)])
        (-0.73091722665244196,
          array([ 0.44925884,  1.3052767 ,  1.9434184 ,  2.57696569,  3.41634856]),
          0.8789283903979661)
    
    aannssaarrii(x, y)
        Perform the Ansari-Bradley test for equal scale parameters
        
        The Ansari-Bradley test is a non-parametric test for the equality
        of the scale parameter of the distributions from which two
        samples were drawn.
        
        Parameters
        ----------
        x, y : array_like
            arrays of sample data
        
        Returns
        -------
        statistic : float
            The Ansari-Bradley test statistic
        pvalue : float
            The p-value of the hypothesis test
        
        See Also
        --------
        fligner : A non-parametric test for the equality of k variances
        mood : A non-parametric test for the equality of two scale parameters
        
        Notes
        -----
        The p-value given is exact when the sample sizes are both less than
        55 and there are no ties, otherwise a normal approximation for the
        p-value is used.
        
        References
        ----------
        .. [1] Sprent, Peter and N.C. Smeeton.  Applied nonparametric statistical
               methods.  3rd ed. Chapman and Hall/CRC. 2001.  Section 5.8.2.
    
    bbaarrttlleetttt(*args)
        Perform Bartlett's test for equal variances
        
        Bartlett's test tests the null hypothesis that all input samples
        are from populations with equal variances.  For samples
        from significantly non-normal populations, Levene's test
        `levene` is more robust.
        
        Parameters
        ----------
        sample1, sample2,... : array_like
            arrays of sample data.  May be different lengths.
        
        Returns
        -------
        statistic : float
            The test statistic.
        pvalue : float
            The p-value of the test.
        
        See Also
        --------
        fligner : A non-parametric test for the equality of k variances
        levene : A robust parametric test for equality of k variances
        
        Notes
        -----
        Conover et al. (1981) examine many of the existing parametric and
        nonparametric tests by extensive simulations and they conclude that the
        tests proposed by Fligner and Killeen (1976) and Levene (1960) appear to be
        superior in terms of robustness of departures from normality and power [3]_.
        
        References
        ----------
        .. [1]  http://www.itl.nist.gov/div898/handbook/eda/section3/eda357.htm
        
        .. [2]  Snedecor, George W. and Cochran, William G. (1989), Statistical
                  Methods, Eighth Edition, Iowa State University Press.
        
        .. [3] Park, C. and Lindsay, B. G. (1999). Robust Scale Estimation and
               Hypothesis Testing based on Quadratic Inference Function. Technical
               Report #99-03, Center for Likelihood Studies, Pennsylvania State
               University.
        
        .. [4] Bartlett, M. S. (1937). Properties of Sufficiency and Statistical
               Tests. Proceedings of the Royal Society of London. Series A,
               Mathematical and Physical Sciences, Vol. 160, No.901, pp. 268-282.
    
    bbaayyeess__mmvvss(data, alpha=0.9)
        Bayesian confidence intervals for the mean, var, and std.
        
        Parameters
        ----------
        data : array_like
            Input data, if multi-dimensional it is flattened to 1-D by `bayes_mvs`.
            Requires 2 or more data points.
        alpha : float, optional
            Probability that the returned confidence interval contains
            the true parameter.
        
        Returns
        -------
        mean_cntr, var_cntr, std_cntr : tuple
            The three results are for the mean, variance and standard deviation,
            respectively.  Each result is a tuple of the form::
        
                (center, (lower, upper))
        
            with `center` the mean of the conditional pdf of the value given the
            data, and `(lower, upper)` a confidence interval, centered on the
            median, containing the estimate to a probability ``alpha``.
        
        See Also
        --------
        mvsdist
        
        Notes
        -----
        Each tuple of mean, variance, and standard deviation estimates represent
        the (center, (lower, upper)) with center the mean of the conditional pdf
        of the value given the data and (lower, upper) is a confidence interval
        centered on the median, containing the estimate to a probability
        ``alpha``.
        
        Converts data to 1-D and assumes all data has the same mean and variance.
        Uses Jeffrey's prior for variance and std.
        
        Equivalent to ``tuple((x.mean(), x.interval(alpha)) for x in mvsdist(dat))``
        
        References
        ----------
        T.E. Oliphant, "A Bayesian perspective on estimating mean, variance, and
        standard-deviation from data", http://scholarsarchive.byu.edu/facpub/278,
        2006.
        
        Examples
        --------
        First a basic example to demonstrate the outputs:
        
        >>> from scipy import stats
        >>> data = [6, 9, 12, 7, 8, 8, 13]
        >>> mean, var, std = stats.bayes_mvs(data)
        >>> mean
        Mean(statistic=9.0, minmax=(7.103650222612533, 10.896349777387467))
        >>> var
        Variance(statistic=10.0, minmax=(3.176724206..., 24.45910382...))
        >>> std
        Std_dev(statistic=2.9724954732045084, minmax=(1.7823367265645143, 4.945614605014631))
        
        Now we generate some normally distributed random data, and get estimates of
        mean and standard deviation with 95% confidence intervals for those
        estimates:
        
        >>> n_samples = 100000
        >>> data = stats.norm.rvs(size=n_samples)
        >>> res_mean, res_var, res_std = stats.bayes_mvs(data, alpha=0.95)
        
        >>> import matplotlib.pyplot as plt
        >>> fig = plt.figure()
        >>> ax = fig.add_subplot(111)
        >>> ax.hist(data, bins=100, density=True, label='Histogram of data')
        >>> ax.vlines(res_mean.statistic, 0, 0.5, colors='r', label='Estimated mean')
        >>> ax.axvspan(res_mean.minmax[0],res_mean.minmax[1], facecolor='r',
        ...            alpha=0.2, label=r'Estimated mean (95% limits)')
        >>> ax.vlines(res_std.statistic, 0, 0.5, colors='g', label='Estimated scale')
        >>> ax.axvspan(res_std.minmax[0],res_std.minmax[1], facecolor='g', alpha=0.2,
        ...            label=r'Estimated scale (95% limits)')
        
        >>> ax.legend(fontsize=10)
        >>> ax.set_xlim([-4, 4])
        >>> ax.set_ylim([0, 0.5])
        >>> plt.show()
    
    bbiinnnneedd__ssttaattiissttiicc(x, values, statistic='mean', bins=10, range=None)
        Compute a binned statistic for one or more sets of data.
        
        This is a generalization of a histogram function.  A histogram divides
        the space into bins, and returns the count of the number of points in
        each bin.  This function allows the computation of the sum, mean, median,
        or other statistic of the values (or set of values) within each bin.
        
        Parameters
        ----------
        x : (N,) array_like
            A sequence of values to be binned.
        values : (N,) array_like or list of (N,) array_like
            The data on which the statistic will be computed.  This must be
            the same shape as `x`, or a set of sequences - each the same shape as
            `x`.  If `values` is a set of sequences, the statistic will be computed
            on each independently.
        statistic : string or callable, optional
            The statistic to compute (default is 'mean').
            The following statistics are available:
        
              * 'mean' : compute the mean of values for points within each bin.
                Empty bins will be represented by NaN.
              * 'median' : compute the median of values for points within each
                bin. Empty bins will be represented by NaN.
              * 'count' : compute the count of points within each bin.  This is
                identical to an unweighted histogram.  `values` array is not
                referenced.
              * 'sum' : compute the sum of values for points within each bin.
                This is identical to a weighted histogram.
              * 'min' : compute the minimum of values for points within each bin.
                Empty bins will be represented by NaN.
              * 'max' : compute the maximum of values for point within each bin.
                Empty bins will be represented by NaN.
              * function : a user-defined function which takes a 1D array of
                values, and outputs a single numerical statistic. This function
                will be called on the values in each bin.  Empty bins will be
                represented by function([]), or NaN if this returns an error.
        
        bins : int or sequence of scalars, optional
            If `bins` is an int, it defines the number of equal-width bins in the
            given range (10 by default).  If `bins` is a sequence, it defines the
            bin edges, including the rightmost edge, allowing for non-uniform bin
            widths.  Values in `x` that are smaller than lowest bin edge are
            assigned to bin number 0, values beyond the highest bin are assigned to
            ``bins[-1]``.  If the bin edges are specified, the number of bins will
            be, (nx = len(bins)-1).
        range : (float, float) or [(float, float)], optional
            The lower and upper range of the bins.  If not provided, range
            is simply ``(x.min(), x.max())``.  Values outside the range are
            ignored.
        
        Returns
        -------
        statistic : array
            The values of the selected statistic in each bin.
        bin_edges : array of dtype float
            Return the bin edges ``(length(statistic)+1)``.
        binnumber: 1-D ndarray of ints
            Indices of the bins (corresponding to `bin_edges`) in which each value
            of `x` belongs.  Same length as `values`.  A binnumber of `i` means the
            corresponding value is between (bin_edges[i-1], bin_edges[i]).
        
        See Also
        --------
        numpy.digitize, numpy.histogram, binned_statistic_2d, binned_statistic_dd
        
        Notes
        -----
        All but the last (righthand-most) bin is half-open.  In other words, if
        `bins` is ``[1, 2, 3, 4]``, then the first bin is ``[1, 2)`` (including 1,
        but excluding 2) and the second ``[2, 3)``.  The last bin, however, is
        ``[3, 4]``, which *includes* 4.
        
        .. versionadded:: 0.11.0
        
        Examples
        --------
        >>> from scipy import stats
        >>> import matplotlib.pyplot as plt
        
        First some basic examples:
        
        Create two evenly spaced bins in the range of the given sample, and sum the
        corresponding values in each of those bins:
        
        >>> values = [1.0, 1.0, 2.0, 1.5, 3.0]
        >>> stats.binned_statistic([1, 1, 2, 5, 7], values, 'sum', bins=2)
        (array([ 4. ,  4.5]), array([ 1.,  4.,  7.]), array([1, 1, 1, 2, 2]))
        
        Multiple arrays of values can also be passed.  The statistic is calculated
        on each set independently:
        
        >>> values = [[1.0, 1.0, 2.0, 1.5, 3.0], [2.0, 2.0, 4.0, 3.0, 6.0]]
        >>> stats.binned_statistic([1, 1, 2, 5, 7], values, 'sum', bins=2)
        (array([[ 4. ,  4.5], [ 8. ,  9. ]]), array([ 1.,  4.,  7.]),
            array([1, 1, 1, 2, 2]))
        
        >>> stats.binned_statistic([1, 2, 1, 2, 4], np.arange(5), statistic='mean',
        ...                        bins=3)
        (array([ 1.,  2.,  4.]), array([ 1.,  2.,  3.,  4.]),
            array([1, 2, 1, 2, 3]))
        
        As a second example, we now generate some random data of sailing boat speed
        as a function of wind speed, and then determine how fast our boat is for
        certain wind speeds:
        
        >>> windspeed = 8 * np.random.rand(500)
        >>> boatspeed = .3 * windspeed**.5 + .2 * np.random.rand(500)
        >>> bin_means, bin_edges, binnumber = stats.binned_statistic(windspeed,
        ...                 boatspeed, statistic='median', bins=[1,2,3,4,5,6,7])
        >>> plt.figure()
        >>> plt.plot(windspeed, boatspeed, 'b.', label='raw data')
        >>> plt.hlines(bin_means, bin_edges[:-1], bin_edges[1:], colors='g', lw=5,
        ...            label='binned statistic of data')
        >>> plt.legend()
        
        Now we can use ``binnumber`` to select all datapoints with a windspeed
        below 1:
        
        >>> low_boatspeed = boatspeed[binnumber == 0]
        
        As a final example, we will use ``bin_edges`` and ``binnumber`` to make a
        plot of a distribution that shows the mean and distribution around that
        mean per bin, on top of a regular histogram and the probability
        distribution function:
        
        >>> x = np.linspace(0, 5, num=500)
        >>> x_pdf = stats.maxwell.pdf(x)
        >>> samples = stats.maxwell.rvs(size=10000)
        
        >>> bin_means, bin_edges, binnumber = stats.binned_statistic(x, x_pdf,
        ...         statistic='mean', bins=25)
        >>> bin_width = (bin_edges[1] - bin_edges[0])
        >>> bin_centers = bin_edges[1:] - bin_width/2
        
        >>> plt.figure()
        >>> plt.hist(samples, bins=50, density=True, histtype='stepfilled',
        ...          alpha=0.2, label='histogram of data')
        >>> plt.plot(x, x_pdf, 'r-', label='analytical pdf')
        >>> plt.hlines(bin_means, bin_edges[:-1], bin_edges[1:], colors='g', lw=2,
        ...            label='binned statistic of data')
        >>> plt.plot((binnumber - 0.5) * bin_width, x_pdf, 'g.', alpha=0.5)
        >>> plt.legend(fontsize=10)
        >>> plt.show()
    
    bbiinnnneedd__ssttaattiissttiicc__22dd(x, y, values, statistic='mean', bins=10, range=None, expand_binnumbers=False)
        Compute a bidimensional binned statistic for one or more sets of data.
        
        This is a generalization of a histogram2d function.  A histogram divides
        the space into bins, and returns the count of the number of points in
        each bin.  This function allows the computation of the sum, mean, median,
        or other statistic of the values (or set of values) within each bin.
        
        Parameters
        ----------
        x : (N,) array_like
            A sequence of values to be binned along the first dimension.
        y : (N,) array_like
            A sequence of values to be binned along the second dimension.
        values : (N,) array_like or list of (N,) array_like
            The data on which the statistic will be computed.  This must be
            the same shape as `x`, or a list of sequences - each with the same
            shape as `x`.  If `values` is such a list, the statistic will be
            computed on each independently.
        statistic : string or callable, optional
            The statistic to compute (default is 'mean').
            The following statistics are available:
        
              * 'mean' : compute the mean of values for points within each bin.
                Empty bins will be represented by NaN.
              * 'median' : compute the median of values for points within each
                bin. Empty bins will be represented by NaN.
              * 'count' : compute the count of points within each bin.  This is
                identical to an unweighted histogram.  `values` array is not
                referenced.
              * 'sum' : compute the sum of values for points within each bin.
                This is identical to a weighted histogram.
              * 'min' : compute the minimum of values for points within each bin.
                Empty bins will be represented by NaN.
              * 'max' : compute the maximum of values for point within each bin.
                Empty bins will be represented by NaN.
              * function : a user-defined function which takes a 1D array of
                values, and outputs a single numerical statistic. This function
                will be called on the values in each bin.  Empty bins will be
                represented by function([]), or NaN if this returns an error.
        
        bins : int or [int, int] or array_like or [array, array], optional
            The bin specification:
        
              * the number of bins for the two dimensions (nx = ny = bins),
              * the number of bins in each dimension (nx, ny = bins),
              * the bin edges for the two dimensions (x_edge = y_edge = bins),
              * the bin edges in each dimension (x_edge, y_edge = bins).
        
            If the bin edges are specified, the number of bins will be,
            (nx = len(x_edge)-1, ny = len(y_edge)-1).
        
        range : (2,2) array_like, optional
            The leftmost and rightmost edges of the bins along each dimension
            (if not specified explicitly in the `bins` parameters):
            [[xmin, xmax], [ymin, ymax]]. All values outside of this range will be
            considered outliers and not tallied in the histogram.
        expand_binnumbers : bool, optional
            'False' (default): the returned `binnumber` is a shape (N,) array of
            linearized bin indices.
            'True': the returned `binnumber` is 'unraveled' into a shape (2,N)
            ndarray, where each row gives the bin numbers in the corresponding
            dimension.
            See the `binnumber` returned value, and the `Examples` section.
        
            .. versionadded:: 0.17.0
        
        Returns
        -------
        statistic : (nx, ny) ndarray
            The values of the selected statistic in each two-dimensional bin.
        x_edge : (nx + 1) ndarray
            The bin edges along the first dimension.
        y_edge : (ny + 1) ndarray
            The bin edges along the second dimension.
        binnumber : (N,) array of ints or (2,N) ndarray of ints
            This assigns to each element of `sample` an integer that represents the
            bin in which this observation falls.  The representation depends on the
            `expand_binnumbers` argument.  See `Notes` for details.
        
        
        See Also
        --------
        numpy.digitize, numpy.histogram2d, binned_statistic, binned_statistic_dd
        
        Notes
        -----
        Binedges:
        All but the last (righthand-most) bin is half-open.  In other words, if
        `bins` is ``[1, 2, 3, 4]``, then the first bin is ``[1, 2)`` (including 1,
        but excluding 2) and the second ``[2, 3)``.  The last bin, however, is
        ``[3, 4]``, which *includes* 4.
        
        `binnumber`:
        This returned argument assigns to each element of `sample` an integer that
        represents the bin in which it belongs.  The representation depends on the
        `expand_binnumbers` argument. If 'False' (default): The returned
        `binnumber` is a shape (N,) array of linearized indices mapping each
        element of `sample` to its corresponding bin (using row-major ordering).
        If 'True': The returned `binnumber` is a shape (2,N) ndarray where
        each row indicates bin placements for each dimension respectively.  In each
        dimension, a binnumber of `i` means the corresponding value is between
        (D_edge[i-1], D_edge[i]), where 'D' is either 'x' or 'y'.
        
        .. versionadded:: 0.11.0
        
        Examples
        --------
        >>> from scipy import stats
        
        Calculate the counts with explicit bin-edges:
        
        >>> x = [0.1, 0.1, 0.1, 0.6]
        >>> y = [2.1, 2.6, 2.1, 2.1]
        >>> binx = [0.0, 0.5, 1.0]
        >>> biny = [2.0, 2.5, 3.0]
        >>> ret = stats.binned_statistic_2d(x, y, None, 'count', bins=[binx,biny])
        >>> ret.statistic
        array([[ 2.,  1.],
               [ 1.,  0.]])
        
        The bin in which each sample is placed is given by the `binnumber`
        returned parameter.  By default, these are the linearized bin indices:
        
        >>> ret.binnumber
        array([5, 6, 5, 9])
        
        The bin indices can also be expanded into separate entries for each
        dimension using the `expand_binnumbers` parameter:
        
        >>> ret = stats.binned_statistic_2d(x, y, None, 'count', bins=[binx,biny],
        ...                                 expand_binnumbers=True)
        >>> ret.binnumber
        array([[1, 1, 1, 2],
               [1, 2, 1, 1]])
        
        Which shows that the first three elements belong in the xbin 1, and the
        fourth into xbin 2; and so on for y.
    
    bbiinnnneedd__ssttaattiissttiicc__dddd(sample, values, statistic='mean', bins=10, range=None, expand_binnumbers=False)
        Compute a multidimensional binned statistic for a set of data.
        
        This is a generalization of a histogramdd function.  A histogram divides
        the space into bins, and returns the count of the number of points in
        each bin.  This function allows the computation of the sum, mean, median,
        or other statistic of the values within each bin.
        
        Parameters
        ----------
        sample : array_like
            Data to histogram passed as a sequence of D arrays of length N, or
            as an (N,D) array.
        values : (N,) array_like or list of (N,) array_like
            The data on which the statistic will be computed.  This must be
            the same shape as `x`, or a list of sequences - each with the same
            shape as `x`.  If `values` is such a list, the statistic will be
            computed on each independently.
        statistic : string or callable, optional
            The statistic to compute (default is 'mean').
            The following statistics are available:
        
              * 'mean' : compute the mean of values for points within each bin.
                Empty bins will be represented by NaN.
              * 'median' : compute the median of values for points within each
                bin. Empty bins will be represented by NaN.
              * 'count' : compute the count of points within each bin.  This is
                identical to an unweighted histogram.  `values` array is not
                referenced.
              * 'sum' : compute the sum of values for points within each bin.
                This is identical to a weighted histogram.
              * 'min' : compute the minimum of values for points within each bin.
                Empty bins will be represented by NaN.
              * 'max' : compute the maximum of values for point within each bin.
                Empty bins will be represented by NaN.
              * function : a user-defined function which takes a 1D array of
                values, and outputs a single numerical statistic. This function
                will be called on the values in each bin.  Empty bins will be
                represented by function([]), or NaN if this returns an error.
        
        bins : sequence or int, optional
            The bin specification must be in one of the following forms:
        
              * A sequence of arrays describing the bin edges along each dimension.
              * The number of bins for each dimension (nx, ny, ... = bins).
              * The number of bins for all dimensions (nx = ny = ... = bins).
        
        range : sequence, optional
            A sequence of lower and upper bin edges to be used if the edges are
            not given explicitly in `bins`. Defaults to the minimum and maximum
            values along each dimension.
        expand_binnumbers : bool, optional
            'False' (default): the returned `binnumber` is a shape (N,) array of
            linearized bin indices.
            'True': the returned `binnumber` is 'unraveled' into a shape (D,N)
            ndarray, where each row gives the bin numbers in the corresponding
            dimension.
            See the `binnumber` returned value, and the `Examples` section of
            `binned_statistic_2d`.
        
            .. versionadded:: 0.17.0
        
        Returns
        -------
        statistic : ndarray, shape(nx1, nx2, nx3,...)
            The values of the selected statistic in each two-dimensional bin.
        bin_edges : list of ndarrays
            A list of D arrays describing the (nxi + 1) bin edges for each
            dimension.
        binnumber : (N,) array of ints or (D,N) ndarray of ints
            This assigns to each element of `sample` an integer that represents the
            bin in which this observation falls.  The representation depends on the
            `expand_binnumbers` argument.  See `Notes` for details.
        
        
        See Also
        --------
        numpy.digitize, numpy.histogramdd, binned_statistic, binned_statistic_2d
        
        Notes
        -----
        Binedges:
        All but the last (righthand-most) bin is half-open in each dimension.  In
        other words, if `bins` is ``[1, 2, 3, 4]``, then the first bin is
        ``[1, 2)`` (including 1, but excluding 2) and the second ``[2, 3)``.  The
        last bin, however, is ``[3, 4]``, which *includes* 4.
        
        `binnumber`:
        This returned argument assigns to each element of `sample` an integer that
        represents the bin in which it belongs.  The representation depends on the
        `expand_binnumbers` argument. If 'False' (default): The returned
        `binnumber` is a shape (N,) array of linearized indices mapping each
        element of `sample` to its corresponding bin (using row-major ordering).
        If 'True': The returned `binnumber` is a shape (D,N) ndarray where
        each row indicates bin placements for each dimension respectively.  In each
        dimension, a binnumber of `i` means the corresponding value is between
        (bin_edges[D][i-1], bin_edges[D][i]), for each dimension 'D'.
        
        .. versionadded:: 0.11.0
    
    bbiinnoomm__tteesstt(x, n=None, p=0.5, alternative='two-sided')
        Perform a test that the probability of success is p.
        
        This is an exact, two-sided test of the null hypothesis
        that the probability of success in a Bernoulli experiment
        is `p`.
        
        Parameters
        ----------
        x : integer or array_like
            the number of successes, or if x has length 2, it is the
            number of successes and the number of failures.
        n : integer
            the number of trials.  This is ignored if x gives both the
            number of successes and failures
        p : float, optional
            The hypothesized probability of success.  0 <= p <= 1. The
            default value is p = 0.5
        alternative : {'two-sided', 'greater', 'less'}, optional
            Indicates the alternative hypothesis. The default value is
            'two-sided'.
        
        Returns
        -------
        p-value : float
            The p-value of the hypothesis test
        
        References
        ----------
        .. [1] http://en.wikipedia.org/wiki/Binomial_test
    
    bbooxxccooxx(x, lmbda=None, alpha=None)
        Return a positive dataset transformed by a Box-Cox power transformation.
        
        Parameters
        ----------
        x : ndarray
            Input array.  Should be 1-dimensional.
        lmbda : {None, scalar}, optional
            If `lmbda` is not None, do the transformation for that value.
        
            If `lmbda` is None, find the lambda that maximizes the log-likelihood
            function and return it as the second output argument.
        alpha : {None, float}, optional
            If ``alpha`` is not None, return the ``100 * (1-alpha)%`` confidence
            interval for `lmbda` as the third output argument.
            Must be between 0.0 and 1.0.
        
        Returns
        -------
        boxcox : ndarray
            Box-Cox power transformed array.
        maxlog : float, optional
            If the `lmbda` parameter is None, the second returned argument is
            the lambda that maximizes the log-likelihood function.
        (min_ci, max_ci) : tuple of float, optional
            If `lmbda` parameter is None and ``alpha`` is not None, this returned
            tuple of floats represents the minimum and maximum confidence limits
            given ``alpha``.
        
        See Also
        --------
        probplot, boxcox_normplot, boxcox_normmax, boxcox_llf
        
        Notes
        -----
        The Box-Cox transform is given by::
        
            y = (x**lmbda - 1) / lmbda,  for lmbda > 0
                log(x),                  for lmbda = 0
        
        `boxcox` requires the input data to be positive.  Sometimes a Box-Cox
        transformation provides a shift parameter to achieve this; `boxcox` does
        not.  Such a shift parameter is equivalent to adding a positive constant to
        `x` before calling `boxcox`.
        
        The confidence limits returned when ``alpha`` is provided give the interval
        where:
        
        .. math::
        
            llf(\hat{\lambda}) - llf(\lambda) < \frac{1}{2}\chi^2(1 - \alpha, 1),
        
        with ``llf`` the log-likelihood function and :math:`\chi^2` the chi-squared
        function.
        
        References
        ----------
        G.E.P. Box and D.R. Cox, "An Analysis of Transformations", Journal of the
        Royal Statistical Society B, 26, 211-252 (1964).
        
        Examples
        --------
        >>> from scipy import stats
        >>> import matplotlib.pyplot as plt
        
        We generate some random variates from a non-normal distribution and make a
        probability plot for it, to show it is non-normal in the tails:
        
        >>> fig = plt.figure()
        >>> ax1 = fig.add_subplot(211)
        >>> x = stats.loggamma.rvs(5, size=500) + 5
        >>> prob = stats.probplot(x, dist=stats.norm, plot=ax1)
        >>> ax1.set_xlabel('')
        >>> ax1.set_title('Probplot against normal distribution')
        
        We now use `boxcox` to transform the data so it's closest to normal:
        
        >>> ax2 = fig.add_subplot(212)
        >>> xt, _ = stats.boxcox(x)
        >>> prob = stats.probplot(xt, dist=stats.norm, plot=ax2)
        >>> ax2.set_title('Probplot after Box-Cox transformation')
        
        >>> plt.show()
    
    bbooxxccooxx__llllff(lmb, data)
        The boxcox log-likelihood function.
        
        Parameters
        ----------
        lmb : scalar
            Parameter for Box-Cox transformation.  See `boxcox` for details.
        data : array_like
            Data to calculate Box-Cox log-likelihood for.  If `data` is
            multi-dimensional, the log-likelihood is calculated along the first
            axis.
        
        Returns
        -------
        llf : float or ndarray
            Box-Cox log-likelihood of `data` given `lmb`.  A float for 1-D `data`,
            an array otherwise.
        
        See Also
        --------
        boxcox, probplot, boxcox_normplot, boxcox_normmax
        
        Notes
        -----
        The Box-Cox log-likelihood function is defined here as
        
        .. math::
        
            llf = (\lambda - 1) \sum_i(\log(x_i)) -
                  N/2 \log(\sum_i (y_i - \bar{y})^2 / N),
        
        where ``y`` is the Box-Cox transformed input data ``x``.
        
        Examples
        --------
        >>> from scipy import stats
        >>> import matplotlib.pyplot as plt
        >>> from mpl_toolkits.axes_grid1.inset_locator import inset_axes
        >>> np.random.seed(1245)
        
        Generate some random variates and calculate Box-Cox log-likelihood values
        for them for a range of ``lmbda`` values:
        
        >>> x = stats.loggamma.rvs(5, loc=10, size=1000)
        >>> lmbdas = np.linspace(-2, 10)
        >>> llf = np.zeros(lmbdas.shape, dtype=float)
        >>> for ii, lmbda in enumerate(lmbdas):
        ...     llf[ii] = stats.boxcox_llf(lmbda, x)
        
        Also find the optimal lmbda value with `boxcox`:
        
        >>> x_most_normal, lmbda_optimal = stats.boxcox(x)
        
        Plot the log-likelihood as function of lmbda.  Add the optimal lmbda as a
        horizontal line to check that that's really the optimum:
        
        >>> fig = plt.figure()
        >>> ax = fig.add_subplot(111)
        >>> ax.plot(lmbdas, llf, 'b.-')
        >>> ax.axhline(stats.boxcox_llf(lmbda_optimal, x), color='r')
        >>> ax.set_xlabel('lmbda parameter')
        >>> ax.set_ylabel('Box-Cox log-likelihood')
        
        Now add some probability plots to show that where the log-likelihood is
        maximized the data transformed with `boxcox` looks closest to normal:
        
        >>> locs = [3, 10, 4]  # 'lower left', 'center', 'lower right'
        >>> for lmbda, loc in zip([-1, lmbda_optimal, 9], locs):
        ...     xt = stats.boxcox(x, lmbda=lmbda)
        ...     (osm, osr), (slope, intercept, r_sq) = stats.probplot(xt)
        ...     ax_inset = inset_axes(ax, width="20%", height="20%", loc=loc)
        ...     ax_inset.plot(osm, osr, 'c.', osm, slope*osm + intercept, 'k-')
        ...     ax_inset.set_xticklabels([])
        ...     ax_inset.set_yticklabels([])
        ...     ax_inset.set_title('$\lambda=%1.2f$' % lmbda)
        
        >>> plt.show()
    
    bbooxxccooxx__nnoorrmmmmaaxx(x, brack=(-2.0, 2.0), method='pearsonr')
        Compute optimal Box-Cox transform parameter for input data.
        
        Parameters
        ----------
        x : array_like
            Input array.
        brack : 2-tuple, optional
            The starting interval for a downhill bracket search with
            `optimize.brent`.  Note that this is in most cases not critical; the
            final result is allowed to be outside this bracket.
        method : str, optional
            The method to determine the optimal transform parameter (`boxcox`
            ``lmbda`` parameter). Options are:
        
            'pearsonr'  (default)
                Maximizes the Pearson correlation coefficient between
                ``y = boxcox(x)`` and the expected values for ``y`` if `x` would be
                normally-distributed.
        
            'mle'
                Minimizes the log-likelihood `boxcox_llf`.  This is the method used
                in `boxcox`.
        
            'all'
                Use all optimization methods available, and return all results.
                Useful to compare different methods.
        
        Returns
        -------
        maxlog : float or ndarray
            The optimal transform parameter found.  An array instead of a scalar
            for ``method='all'``.
        
        See Also
        --------
        boxcox, boxcox_llf, boxcox_normplot
        
        Examples
        --------
        >>> from scipy import stats
        >>> import matplotlib.pyplot as plt
        >>> np.random.seed(1234)  # make this example reproducible
        
        Generate some data and determine optimal ``lmbda`` in various ways:
        
        >>> x = stats.loggamma.rvs(5, size=30) + 5
        >>> y, lmax_mle = stats.boxcox(x)
        >>> lmax_pearsonr = stats.boxcox_normmax(x)
        
        >>> lmax_mle
        7.177...
        >>> lmax_pearsonr
        7.916...
        >>> stats.boxcox_normmax(x, method='all')
        array([ 7.91667384,  7.17718692])
        
        >>> fig = plt.figure()
        >>> ax = fig.add_subplot(111)
        >>> prob = stats.boxcox_normplot(x, -10, 10, plot=ax)
        >>> ax.axvline(lmax_mle, color='r')
        >>> ax.axvline(lmax_pearsonr, color='g', ls='--')
        
        >>> plt.show()
    
    bbooxxccooxx__nnoorrmmpplloott(x, la, lb, plot=None, N=80)
        Compute parameters for a Box-Cox normality plot, optionally show it.
        
        A Box-Cox normality plot shows graphically what the best transformation
        parameter is to use in `boxcox` to obtain a distribution that is close
        to normal.
        
        Parameters
        ----------
        x : array_like
            Input array.
        la, lb : scalar
            The lower and upper bounds for the ``lmbda`` values to pass to `boxcox`
            for Box-Cox transformations.  These are also the limits of the
            horizontal axis of the plot if that is generated.
        plot : object, optional
            If given, plots the quantiles and least squares fit.
            `plot` is an object that has to have methods "plot" and "text".
            The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
            or a custom object with the same methods.
            Default is None, which means that no plot is created.
        N : int, optional
            Number of points on the horizontal axis (equally distributed from
            `la` to `lb`).
        
        Returns
        -------
        lmbdas : ndarray
            The ``lmbda`` values for which a Box-Cox transform was done.
        ppcc : ndarray
            Probability Plot Correlelation Coefficient, as obtained from `probplot`
            when fitting the Box-Cox transformed input `x` against a normal
            distribution.
        
        See Also
        --------
        probplot, boxcox, boxcox_normmax, boxcox_llf, ppcc_max
        
        Notes
        -----
        Even if `plot` is given, the figure is not shown or saved by
        `boxcox_normplot`; ``plt.show()`` or ``plt.savefig('figname.png')``
        should be used after calling `probplot`.
        
        Examples
        --------
        >>> from scipy import stats
        >>> import matplotlib.pyplot as plt
        
        Generate some non-normally distributed data, and create a Box-Cox plot:
        
        >>> x = stats.loggamma.rvs(5, size=500) + 5
        >>> fig = plt.figure()
        >>> ax = fig.add_subplot(111)
        >>> prob = stats.boxcox_normplot(x, -20, 20, plot=ax)
        
        Determine and plot the optimal ``lmbda`` to transform ``x`` and plot it in
        the same plot:
        
        >>> _, maxlog = stats.boxcox(x)
        >>> ax.axvline(maxlog, color='r')
        
        >>> plt.show()
    
    cchhii22__ccoonnttiinnggeennccyy(observed, correction=True, lambda_=None)
        Chi-square test of independence of variables in a contingency table.
        
        This function computes the chi-square statistic and p-value for the
        hypothesis test of independence of the observed frequencies in the
        contingency table [1]_ `observed`.  The expected frequencies are computed
        based on the marginal sums under the assumption of independence; see
        `scipy.stats.contingency.expected_freq`.  The number of degrees of
        freedom is (expressed using numpy functions and attributes)::
        
            dof = observed.size - sum(observed.shape) + observed.ndim - 1
        
        
        Parameters
        ----------
        observed : array_like
            The contingency table. The table contains the observed frequencies
            (i.e. number of occurrences) in each category.  In the two-dimensional
            case, the table is often described as an "R x C table".
        correction : bool, optional
            If True, *and* the degrees of freedom is 1, apply Yates' correction
            for continuity.  The effect of the correction is to adjust each
            observed value by 0.5 towards the corresponding expected value.
        lambda_ : float or str, optional.
            By default, the statistic computed in this test is Pearson's
            chi-squared statistic [2]_.  `lambda_` allows a statistic from the
            Cressie-Read power divergence family [3]_ to be used instead.  See
            `power_divergence` for details.
        
        Returns
        -------
        chi2 : float
            The test statistic.
        p : float
            The p-value of the test
        dof : int
            Degrees of freedom
        expected : ndarray, same shape as `observed`
            The expected frequencies, based on the marginal sums of the table.
        
        See Also
        --------
        contingency.expected_freq
        fisher_exact
        chisquare
        power_divergence
        
        Notes
        -----
        An often quoted guideline for the validity of this calculation is that
        the test should be used only if the observed and expected frequencies
        in each cell are at least 5.
        
        This is a test for the independence of different categories of a
        population. The test is only meaningful when the dimension of
        `observed` is two or more.  Applying the test to a one-dimensional
        table will always result in `expected` equal to `observed` and a
        chi-square statistic equal to 0.
        
        This function does not handle masked arrays, because the calculation
        does not make sense with missing values.
        
        Like stats.chisquare, this function computes a chi-square statistic;
        the convenience this function provides is to figure out the expected
        frequencies and degrees of freedom from the given contingency table.
        If these were already known, and if the Yates' correction was not
        required, one could use stats.chisquare.  That is, if one calls::
        
            chi2, p, dof, ex = chi2_contingency(obs, correction=False)
        
        then the following is true::
        
            (chi2, p) == stats.chisquare(obs.ravel(), f_exp=ex.ravel(),
                                         ddof=obs.size - 1 - dof)
        
        The `lambda_` argument was added in version 0.13.0 of scipy.
        
        References
        ----------
        .. [1] "Contingency table", http://en.wikipedia.org/wiki/Contingency_table
        .. [2] "Pearson's chi-squared test",
               http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test
        .. [3] Cressie, N. and Read, T. R. C., "Multinomial Goodness-of-Fit
               Tests", J. Royal Stat. Soc. Series B, Vol. 46, No. 3 (1984),
               pp. 440-464.
        
        Examples
        --------
        A two-way example (2 x 3):
        
        >>> from scipy.stats import chi2_contingency
        >>> obs = np.array([[10, 10, 20], [20, 20, 20]])
        >>> chi2_contingency(obs)
        (2.7777777777777777,
         0.24935220877729619,
         2,
         array([[ 12.,  12.,  16.],
                [ 18.,  18.,  24.]]))
        
        Perform the test using the log-likelihood ratio (i.e. the "G-test")
        instead of Pearson's chi-squared statistic.
        
        >>> g, p, dof, expctd = chi2_contingency(obs, lambda_="log-likelihood")
        >>> g, p
        (2.7688587616781319, 0.25046668010954165)
        
        A four-way example (2 x 2 x 2 x 2):
        
        >>> obs = np.array(
        ...     [[[[12, 17],
        ...        [11, 16]],
        ...       [[11, 12],
        ...        [15, 16]]],
        ...      [[[23, 15],
        ...        [30, 22]],
        ...       [[14, 17],
        ...        [15, 16]]]])
        >>> chi2_contingency(obs)
        (8.7584514426741897,
         0.64417725029295503,
         11,
         array([[[[ 14.15462386,  14.15462386],
                  [ 16.49423111,  16.49423111]],
                 [[ 11.2461395 ,  11.2461395 ],
                  [ 13.10500554,  13.10500554]]],
                [[[ 19.5591166 ,  19.5591166 ],
                  [ 22.79202844,  22.79202844]],
                 [[ 15.54012004,  15.54012004],
                  [ 18.10873492,  18.10873492]]]]))
    
    cchhiissqquuaarree(f_obs, f_exp=None, ddof=0, axis=0)
        Calculate a one-way chi square test.
        
        The chi square test tests the null hypothesis that the categorical data
        has the given frequencies.
        
        Parameters
        ----------
        f_obs : array_like
            Observed frequencies in each category.
        f_exp : array_like, optional
            Expected frequencies in each category.  By default the categories are
            assumed to be equally likely.
        ddof : int, optional
            "Delta degrees of freedom": adjustment to the degrees of freedom
            for the p-value.  The p-value is computed using a chi-squared
            distribution with ``k - 1 - ddof`` degrees of freedom, where `k`
            is the number of observed frequencies.  The default value of `ddof`
            is 0.
        axis : int or None, optional
            The axis of the broadcast result of `f_obs` and `f_exp` along which to
            apply the test.  If axis is None, all values in `f_obs` are treated
            as a single data set.  Default is 0.
        
        Returns
        -------
        chisq : float or ndarray
            The chi-squared test statistic.  The value is a float if `axis` is
            None or `f_obs` and `f_exp` are 1-D.
        p : float or ndarray
            The p-value of the test.  The value is a float if `ddof` and the
            return value `chisq` are scalars.
        
        See Also
        --------
        power_divergence
        mstats.chisquare
        
        Notes
        -----
        This test is invalid when the observed or expected frequencies in each
        category are too small.  A typical rule is that all of the observed
        and expected frequencies should be at least 5.
        
        The default degrees of freedom, k-1, are for the case when no parameters
        of the distribution are estimated. If p parameters are estimated by
        efficient maximum likelihood then the correct degrees of freedom are
        k-1-p. If the parameters are estimated in a different way, then the
        dof can be between k-1-p and k-1. However, it is also possible that
        the asymptotic distribution is not a chisquare, in which case this
        test is not appropriate.
        
        References
        ----------
        .. [1] Lowry, Richard.  "Concepts and Applications of Inferential
               Statistics". Chapter 8. http://faculty.vassar.edu/lowry/ch8pt1.html
        .. [2] "Chi-squared test", http://en.wikipedia.org/wiki/Chi-squared_test
        
        Examples
        --------
        When just `f_obs` is given, it is assumed that the expected frequencies
        are uniform and given by the mean of the observed frequencies.
        
        >>> from scipy.stats import chisquare
        >>> chisquare([16, 18, 16, 14, 12, 12])
        (2.0, 0.84914503608460956)
        
        With `f_exp` the expected frequencies can be given.
        
        >>> chisquare([16, 18, 16, 14, 12, 12], f_exp=[16, 16, 16, 16, 16, 8])
        (3.5, 0.62338762774958223)
        
        When `f_obs` is 2-D, by default the test is applied to each column.
        
        >>> obs = np.array([[16, 18, 16, 14, 12, 12], [32, 24, 16, 28, 20, 24]]).T
        >>> obs.shape
        (6, 2)
        >>> chisquare(obs)
        (array([ 2.        ,  6.66666667]), array([ 0.84914504,  0.24663415]))
        
        By setting ``axis=None``, the test is applied to all data in the array,
        which is equivalent to applying the test to the flattened array.
        
        >>> chisquare(obs, axis=None)
        (23.31034482758621, 0.015975692534127565)
        >>> chisquare(obs.ravel())
        (23.31034482758621, 0.015975692534127565)
        
        `ddof` is the change to make to the default degrees of freedom.
        
        >>> chisquare([16, 18, 16, 14, 12, 12], ddof=1)
        (2.0, 0.73575888234288467)
        
        The calculation of the p-values is done by broadcasting the
        chi-squared statistic with `ddof`.
        
        >>> chisquare([16, 18, 16, 14, 12, 12], ddof=[0,1,2])
        (2.0, array([ 0.84914504,  0.73575888,  0.5724067 ]))
        
        `f_obs` and `f_exp` are also broadcast.  In the following, `f_obs` has
        shape (6,) and `f_exp` has shape (2, 6), so the result of broadcasting
        `f_obs` and `f_exp` has shape (2, 6).  To compute the desired chi-squared
        statistics, we use ``axis=1``:
        
        >>> chisquare([16, 18, 16, 14, 12, 12],
        ...           f_exp=[[16, 16, 16, 16, 16, 8], [8, 20, 20, 16, 12, 12]],
        ...           axis=1)
        (array([ 3.5 ,  9.25]), array([ 0.62338763,  0.09949846]))
    
    cciirrccmmeeaann(samples, high=6.283185307179586, low=0, axis=None)
        Compute the circular mean for samples in a range.
        
        Parameters
        ----------
        samples : array_like
            Input array.
        high : float or int, optional
            High boundary for circular mean range.  Default is ``2*pi``.
        low : float or int, optional
            Low boundary for circular mean range.  Default is 0.
        axis : int, optional
            Axis along which means are computed.  The default is to compute
            the mean of the flattened array.
        
        Returns
        -------
        circmean : float
            Circular mean.
        
        Examples
        --------
        >>> from scipy.stats import circmean
        >>> circmean([0.1, 2*np.pi+0.2, 6*np.pi+0.3])
        0.2
        
        >>> from scipy.stats import circmean
        >>> circmean([0.2, 1.4, 2.6], high = 1, low = 0)
        0.4
    
    cciirrccssttdd(samples, high=6.283185307179586, low=0, axis=None)
        Compute the circular standard deviation for samples assumed to be in the
        range [low to high].
        
        Parameters
        ----------
        samples : array_like
            Input array.
        low : float or int, optional
            Low boundary for circular standard deviation range.  Default is 0.
        high : float or int, optional
            High boundary for circular standard deviation range.
            Default is ``2*pi``.
        axis : int, optional
            Axis along which standard deviations are computed.  The default is
            to compute the standard deviation of the flattened array.
        
        Returns
        -------
        circstd : float
            Circular standard deviation.
        
        Notes
        -----
        This uses a definition of circular standard deviation that in the limit of
        small angles returns a number close to the 'linear' standard deviation.
        
        Examples
        --------
        >>> from scipy.stats import circstd
        >>> circstd([0, 0.1*np.pi/2, 0.001*np.pi, 0.03*np.pi/2])
        0.063564063306
    
    cciirrccvvaarr(samples, high=6.283185307179586, low=0, axis=None)
        Compute the circular variance for samples assumed to be in a range
        
        Parameters
        ----------
        samples : array_like
            Input array.
        low : float or int, optional
            Low boundary for circular variance range.  Default is 0.
        high : float or int, optional
            High boundary for circular variance range.  Default is ``2*pi``.
        axis : int, optional
            Axis along which variances are computed.  The default is to compute
            the variance of the flattened array.
        
        Returns
        -------
        circvar : float
            Circular variance.
        
        Notes
        -----
        This uses a definition of circular variance that in the limit of small
        angles returns a number close to the 'linear' variance.
        
        Examples
        --------
        >>> from scipy.stats import circvar
        >>> circvar([0, 2*np.pi/3, 5*np.pi/3])
        2.19722457734
    
    ccoommbbiinnee__ppvvaalluueess(pvalues, method='fisher', weights=None)
        Methods for combining the p-values of independent tests bearing upon the
        same hypothesis.
        
        Parameters
        ----------
        pvalues : array_like, 1-D
            Array of p-values assumed to come from independent tests.
        method : {'fisher', 'stouffer'}, optional
            Name of method to use to combine p-values. The following methods are
            available:
        
            - "fisher": Fisher's method (Fisher's combined probability test),
              the default.
            - "stouffer": Stouffer's Z-score method.
        weights : array_like, 1-D, optional
            Optional array of weights used only for Stouffer's Z-score method.
        
        Returns
        -------
        statistic: float
            The statistic calculated by the specified method:
            - "fisher": The chi-squared statistic
            - "stouffer": The Z-score
        pval: float
            The combined p-value.
        
        Notes
        -----
        Fisher's method (also known as Fisher's combined probability test) [1]_ uses
        a chi-squared statistic to compute a combined p-value. The closely related
        Stouffer's Z-score method [2]_ uses Z-scores rather than p-values. The
        advantage of Stouffer's method is that it is straightforward to introduce
        weights, which can make Stouffer's method more powerful than Fisher's
        method when the p-values are from studies of different size [3]_ [4]_.
        
        Fisher's method may be extended to combine p-values from dependent tests
        [5]_. Extensions such as Brown's method and Kost's method are not currently
        implemented.
        
        .. versionadded:: 0.15.0
        
        References
        ----------
        .. [1] https://en.wikipedia.org/wiki/Fisher%27s_method
        .. [2] http://en.wikipedia.org/wiki/Fisher's_method#Relation_to_Stouffer.27s_Z-score_method
        .. [3] Whitlock, M. C. "Combining probability from independent tests: the
               weighted Z-method is superior to Fisher's approach." Journal of
               Evolutionary Biology 18, no. 5 (2005): 1368-1373.
        .. [4] Zaykin, Dmitri V. "Optimally weighted Z-test is a powerful method
               for combining probabilities in meta-analysis." Journal of
               Evolutionary Biology 24, no. 8 (2011): 1836-1841.
        .. [5] https://en.wikipedia.org/wiki/Extensions_of_Fisher%27s_method
    
    ccuummffrreeqq(a, numbins=10, defaultreallimits=None, weights=None)
        Return a cumulative frequency histogram, using the histogram function.
        
        A cumulative histogram is a mapping that counts the cumulative number of
        observations in all of the bins up to the specified bin.
        
        Parameters
        ----------
        a : array_like
            Input array.
        numbins : int, optional
            The number of bins to use for the histogram. Default is 10.
        defaultreallimits : tuple (lower, upper), optional
            The lower and upper values for the range of the histogram.
            If no value is given, a range slightly larger than the range of the
            values in `a` is used. Specifically ``(a.min() - s, a.max() + s)``,
            where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.
        weights : array_like, optional
            The weights for each value in `a`. Default is None, which gives each
            value a weight of 1.0
        
        Returns
        -------
        cumcount : ndarray
            Binned values of cumulative frequency.
        lowerlimit : float
            Lower real limit
        binsize : float
            Width of each bin.
        extrapoints : int
            Extra points.
        
        Examples
        --------
        >>> import matplotlib.pyplot as plt
        >>> from scipy import stats
        >>> x = [1, 4, 2, 1, 3, 1]
        >>> res = stats.cumfreq(x, numbins=4, defaultreallimits=(1.5, 5))
        >>> res.cumcount
        array([ 1.,  2.,  3.,  3.])
        >>> res.extrapoints
        3
        
        Create a normal distribution with 1000 random values
        
        >>> rng = np.random.RandomState(seed=12345)
        >>> samples = stats.norm.rvs(size=1000, random_state=rng)
        
        Calculate cumulative frequencies
        
        >>> res = stats.cumfreq(samples, numbins=25)
        
        Calculate space of values for x
        
        >>> x = res.lowerlimit + np.linspace(0, res.binsize*res.cumcount.size,
        ...                                  res.cumcount.size)
        
        Plot histogram and cumulative histogram
        
        >>> fig = plt.figure(figsize=(10, 4))
        >>> ax1 = fig.add_subplot(1, 2, 1)
        >>> ax2 = fig.add_subplot(1, 2, 2)
        >>> ax1.hist(samples, bins=25)
        >>> ax1.set_title('Histogram')
        >>> ax2.bar(x, res.cumcount, width=res.binsize)
        >>> ax2.set_title('Cumulative histogram')
        >>> ax2.set_xlim([x.min(), x.max()])
        
        >>> plt.show()
    
    ddeessccrriibbee(a, axis=0, ddof=1, bias=True, nan_policy='propagate')
        Compute several descriptive statistics of the passed array.
        
        Parameters
        ----------
        a : array_like
           Input data.
        axis : int or None, optional
           Axis along which statistics are calculated. Default is 0.
           If None, compute over the whole array `a`.
        ddof : int, optional
            Delta degrees of freedom (only for variance).  Default is 1.
        bias : bool, optional
            If False, then the skewness and kurtosis calculations are corrected for
            statistical bias.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        nobs : int or ndarray of ints
           Number of observations (length of data along `axis`).
           When 'omit' is chosen as nan_policy, each column is counted separately.
        minmax: tuple of ndarrays or floats
           Minimum and maximum value of data array.
        mean : ndarray or float
           Arithmetic mean of data along axis.
        variance : ndarray or float
           Unbiased variance of the data along axis, denominator is number of
           observations minus one.
        skewness : ndarray or float
           Skewness, based on moment calculations with denominator equal to
           the number of observations, i.e. no degrees of freedom correction.
        kurtosis : ndarray or float
           Kurtosis (Fisher).  The kurtosis is normalized so that it is
           zero for the normal distribution.  No degrees of freedom are used.
        
        See Also
        --------
        skew, kurtosis
        
        Examples
        --------
        >>> from scipy import stats
        >>> a = np.arange(10)
        >>> stats.describe(a)
        DescribeResult(nobs=10, minmax=(0, 9), mean=4.5, variance=9.166666666666666,
                       skewness=0.0, kurtosis=-1.2242424242424244)
        >>> b = [[1, 2], [3, 4]]
        >>> stats.describe(b)
        DescribeResult(nobs=2, minmax=(array([1, 2]), array([3, 4])),
                       mean=array([2., 3.]), variance=array([2., 2.]),
                       skewness=array([0., 0.]), kurtosis=array([-2., -2.]))
    
    eenneerrggyy__ddiissttaannccee(u_values, v_values, u_weights=None, v_weights=None)
        Compute the energy distance between two 1D distributions.
        
        .. versionadded:: 1.0.0
        
        Parameters
        ----------
        u_values, v_values : array_like
            Values observed in the (empirical) distribution.
        u_weights, v_weights : array_like, optional
            Weight for each value. If unspecified, each value is assigned the same
            weight.
            `u_weights` (resp. `v_weights`) must have the same length as
            `u_values` (resp. `v_values`). If the weight sum differs from 1, it
            must still be positive and finite so that the weights can be normalized
            to sum to 1.
        
        Returns
        -------
        distance : float
            The computed distance between the distributions.
        
        Notes
        -----
        The energy distance between two distributions :math:`u` and :math:`v`, whose
        respective CDFs are :math:`U` and :math:`V`, equals to:
        
        .. math::
        
            D(u, v) = \left( 2\mathbb E|X - Y| - \mathbb E|X - X'| -
            \mathbb E|Y - Y'| \right)^{1/2}
        
        where :math:`X` and :math:`X'` (resp. :math:`Y` and :math:`Y'`) are
        independent random variables whose probability distribution is :math:`u`
        (resp. :math:`v`).
        
        As shown in [2]_, for one-dimensional real-valued variables, the energy
        distance is linked to the non-distribution-free version of the Cramer-von
        Mises distance:
        
        .. math::
        
            D(u, v) = \sqrt{2} l_2(u, v) = \left( 2 \int_{-\infty}^{+\infty} (U-V)^2
            \right)^{1/2}
        
        Note that the common Cramer-von Mises criterion uses the distribution-free
        version of the distance. See [2]_ (section 2), for more details about both
        versions of the distance.
        
        The input distributions can be empirical, therefore coming from samples
        whose values are effectively inputs of the function, or they can be seen as
        generalized functions, in which case they are weighted sums of Dirac delta
        functions located at the specified values.
        
        References
        ----------
        .. [1] "Energy distance", https://en.wikipedia.org/wiki/Energy_distance
        .. [2] Szekely "E-statistics: The energy of statistical samples." Bowling
               Green State University, Department of Mathematics and Statistics,
               Technical Report 02-16 (2002).
        .. [3] Rizzo, Szekely "Energy distance." Wiley Interdisciplinary Reviews:
               Computational Statistics, 8(1):27-38 (2015).
        .. [4] Bellemare, Danihelka, Dabney, Mohamed, Lakshminarayanan, Hoyer,
               Munos "The Cramer Distance as a Solution to Biased Wasserstein
               Gradients" (2017). :arXiv:`1705.10743`.
        
        Examples
        --------
        >>> from scipy.stats import energy_distance
        >>> energy_distance([0], [2])
        2.0000000000000004
        >>> energy_distance([0, 8], [0, 8], [3, 1], [2, 2])
        1.0000000000000002
        >>> energy_distance([0.7, 7.4, 2.4, 6.8], [1.4, 8. ],
        ...                 [2.1, 4.2, 7.4, 8. ], [7.6, 8.8])
        0.88003340976158217
    
    eennttrrooppyy(pk, qk=None, base=None)
        Calculate the entropy of a distribution for given probability values.
        
        If only probabilities `pk` are given, the entropy is calculated as
        ``S = -sum(pk * log(pk), axis=0)``.
        
        If `qk` is not None, then compute the Kullback-Leibler divergence
        ``S = sum(pk * log(pk / qk), axis=0)``.
        
        This routine will normalize `pk` and `qk` if they don't sum to 1.
        
        Parameters
        ----------
        pk : sequence
            Defines the (discrete) distribution. ``pk[i]`` is the (possibly
            unnormalized) probability of event ``i``.
        qk : sequence, optional
            Sequence against which the relative entropy is computed. Should be in
            the same format as `pk`.
        base : float, optional
            The logarithmic base to use, defaults to ``e`` (natural logarithm).
        
        Returns
        -------
        S : float
            The calculated entropy.
    
    ff__oonneewwaayy(*args)
        Performs a 1-way ANOVA.
        
        The one-way ANOVA tests the null hypothesis that two or more groups have
        the same population mean.  The test is applied to samples from two or
        more groups, possibly with differing sizes.
        
        Parameters
        ----------
        sample1, sample2, ... : array_like
            The sample measurements for each group.
        
        Returns
        -------
        statistic : float
            The computed F-value of the test.
        pvalue : float
            The associated p-value from the F-distribution.
        
        Notes
        -----
        The ANOVA test has important assumptions that must be satisfied in order
        for the associated p-value to be valid.
        
        1. The samples are independent.
        2. Each sample is from a normally distributed population.
        3. The population standard deviations of the groups are all equal.  This
           property is known as homoscedasticity.
        
        If these assumptions are not true for a given set of data, it may still be
        possible to use the Kruskal-Wallis H-test (`scipy.stats.kruskal`) although
        with some loss of power.
        
        The algorithm is from Heiman[2], pp.394-7.
        
        
        References
        ----------
        .. [1] Lowry, Richard.  "Concepts and Applications of Inferential
               Statistics". Chapter 14.
               http://faculty.vassar.edu/lowry/ch14pt1.html
        
        .. [2] Heiman, G.W.  Research Methods in Statistics. 2002.
        
        .. [3] McDonald, G. H. "Handbook of Biological Statistics", One-way ANOVA.
               http://www.biostathandbook.com/onewayanova.html
        
        Examples
        --------
        >>> import scipy.stats as stats
        
        [3]_ Here are some data on a shell measurement (the length of the anterior
        adductor muscle scar, standardized by dividing by length) in the mussel
        Mytilus trossulus from five locations: Tillamook, Oregon; Newport, Oregon;
        Petersburg, Alaska; Magadan, Russia; and Tvarminne, Finland, taken from a
        much larger data set used in McDonald et al. (1991).
        
        >>> tillamook = [0.0571, 0.0813, 0.0831, 0.0976, 0.0817, 0.0859, 0.0735,
        ...              0.0659, 0.0923, 0.0836]
        >>> newport = [0.0873, 0.0662, 0.0672, 0.0819, 0.0749, 0.0649, 0.0835,
        ...            0.0725]
        >>> petersburg = [0.0974, 0.1352, 0.0817, 0.1016, 0.0968, 0.1064, 0.105]
        >>> magadan = [0.1033, 0.0915, 0.0781, 0.0685, 0.0677, 0.0697, 0.0764,
        ...            0.0689]
        >>> tvarminne = [0.0703, 0.1026, 0.0956, 0.0973, 0.1039, 0.1045]
        >>> stats.f_oneway(tillamook, newport, petersburg, magadan, tvarminne)
        (7.1210194716424473, 0.00028122423145345439)
    
    ffiinndd__rreeppeeaattss(arr)
        Find repeats and repeat counts.
        
        Parameters
        ----------
        arr : array_like
            Input array. This is cast to float64.
        
        Returns
        -------
        values : ndarray
            The unique values from the (flattened) input that are repeated.
        
        counts : ndarray
            Number of times the corresponding 'value' is repeated.
        
        Notes
        -----
        In numpy >= 1.9 `numpy.unique` provides similar functionality. The main
        difference is that `find_repeats` only returns repeated values.
        
        Examples
        --------
        >>> from scipy import stats
        >>> stats.find_repeats([2, 1, 2, 3, 2, 2, 5])
        RepeatedResults(values=array([2.]), counts=array([4]))
        
        >>> stats.find_repeats([[10, 20, 1, 2], [5, 5, 4, 4]])
        RepeatedResults(values=array([4.,  5.]), counts=array([2, 2]))
    
    ffiisshheerr__eexxaacctt(table, alternative='two-sided')
        Performs a Fisher exact test on a 2x2 contingency table.
        
        Parameters
        ----------
        table : array_like of ints
            A 2x2 contingency table.  Elements should be non-negative integers.
        alternative : {'two-sided', 'less', 'greater'}, optional
            Which alternative hypothesis to the null hypothesis the test uses.
            Default is 'two-sided'.
        
        Returns
        -------
        oddsratio : float
            This is prior odds ratio and not a posterior estimate.
        p_value : float
            P-value, the probability of obtaining a distribution at least as
            extreme as the one that was actually observed, assuming that the
            null hypothesis is true.
        
        See Also
        --------
        chi2_contingency : Chi-square test of independence of variables in a
            contingency table.
        
        Notes
        -----
        The calculated odds ratio is different from the one R uses. This scipy
        implementation returns the (more common) "unconditional Maximum
        Likelihood Estimate", while R uses the "conditional Maximum Likelihood
        Estimate".
        
        For tables with large numbers, the (inexact) chi-square test implemented
        in the function `chi2_contingency` can also be used.
        
        Examples
        --------
        Say we spend a few days counting whales and sharks in the Atlantic and
        Indian oceans. In the Atlantic ocean we find 8 whales and 1 shark, in the
        Indian ocean 2 whales and 5 sharks. Then our contingency table is::
        
                    Atlantic  Indian
            whales     8        2
            sharks     1        5
        
        We use this table to find the p-value:
        
        >>> import scipy.stats as stats
        >>> oddsratio, pvalue = stats.fisher_exact([[8, 2], [1, 5]])
        >>> pvalue
        0.0349...
        
        The probability that we would observe this or an even more imbalanced ratio
        by chance is about 3.5%.  A commonly used significance level is 5%--if we
        adopt that, we can therefore conclude that our observed imbalance is
        statistically significant; whales prefer the Atlantic while sharks prefer
        the Indian ocean.
    
    fflliiggnneerr(*args, **kwds)
        Perform Fligner-Killeen test for equality of variance.
        
        Fligner's test tests the null hypothesis that all input samples
        are from populations with equal variances.  Fligner-Killeen's test is
        distribution free when populations are identical [2]_.
        
        Parameters
        ----------
        sample1, sample2, ... : array_like
            Arrays of sample data.  Need not be the same length.
        center : {'mean', 'median', 'trimmed'}, optional
            Keyword argument controlling which function of the data is used in
            computing the test statistic.  The default is 'median'.
        proportiontocut : float, optional
            When `center` is 'trimmed', this gives the proportion of data points
            to cut from each end. (See `scipy.stats.trim_mean`.)
            Default is 0.05.
        
        Returns
        -------
        statistic : float
            The test statistic.
        pvalue : float
            The p-value for the hypothesis test.
        
        See Also
        --------
        bartlett : A parametric test for equality of k variances in normal samples
        levene : A robust parametric test for equality of k variances
        
        Notes
        -----
        As with Levene's test there are three variants of Fligner's test that
        differ by the measure of central tendency used in the test.  See `levene`
        for more information.
        
        Conover et al. (1981) examine many of the existing parametric and
        nonparametric tests by extensive simulations and they conclude that the
        tests proposed by Fligner and Killeen (1976) and Levene (1960) appear to be
        superior in terms of robustness of departures from normality and power [3]_.
        
        References
        ----------
        .. [1] Park, C. and Lindsay, B. G. (1999). Robust Scale Estimation and
               Hypothesis Testing based on Quadratic Inference Function. Technical
               Report #99-03, Center for Likelihood Studies, Pennsylvania State
               University.
               http://cecas.clemson.edu/~cspark/cv/paper/qif/draftqif2.pdf
        
        .. [2] Fligner, M.A. and Killeen, T.J. (1976). Distribution-free two-sample
               tests for scale. 'Journal of the American Statistical Association.'
               71(353), 210-213.
        
        .. [3] Park, C. and Lindsay, B. G. (1999). Robust Scale Estimation and
               Hypothesis Testing based on Quadratic Inference Function. Technical
               Report #99-03, Center for Likelihood Studies, Pennsylvania State
               University.
        
        .. [4] Conover, W. J., Johnson, M. E. and Johnson M. M. (1981). A
               comparative study of tests for homogeneity of variances, with
               applications to the outer continental shelf biding data.
               Technometrics, 23(4), 351-361.
    
    ffrriieeddmmaanncchhiissqquuaarree(*args)
        Compute the Friedman test for repeated measurements
        
        The Friedman test tests the null hypothesis that repeated measurements of
        the same individuals have the same distribution.  It is often used
        to test for consistency among measurements obtained in different ways.
        For example, if two measurement techniques are used on the same set of
        individuals, the Friedman test can be used to determine if the two
        measurement techniques are consistent.
        
        Parameters
        ----------
        measurements1, measurements2, measurements3... : array_like
            Arrays of measurements.  All of the arrays must have the same number
            of elements.  At least 3 sets of measurements must be given.
        
        Returns
        -------
        statistic : float
            the test statistic, correcting for ties
        pvalue : float
            the associated p-value assuming that the test statistic has a chi
            squared distribution
        
        Notes
        -----
        Due to the assumption that the test statistic has a chi squared
        distribution, the p-value is only reliable for n > 10 and more than
        6 repeated measurements.
        
        References
        ----------
        .. [1] http://en.wikipedia.org/wiki/Friedman_test
    
    ggmmeeaann(a, axis=0, dtype=None)
        Compute the geometric mean along the specified axis.
        
        Return the geometric average of the array elements.
        That is:  n-th root of (x1 * x2 * ... * xn)
        
        Parameters
        ----------
        a : array_like
            Input array or object that can be converted to an array.
        axis : int or None, optional
            Axis along which the geometric mean is computed. Default is 0.
            If None, compute over the whole array `a`.
        dtype : dtype, optional
            Type of the returned array and of the accumulator in which the
            elements are summed. If dtype is not specified, it defaults to the
            dtype of a, unless a has an integer dtype with a precision less than
            that of the default platform integer. In that case, the default
            platform integer is used.
        
        Returns
        -------
        gmean : ndarray
            see dtype parameter above
        
        See Also
        --------
        numpy.mean : Arithmetic average
        numpy.average : Weighted average
        hmean : Harmonic mean
        
        Notes
        -----
        The geometric average is computed over a single dimension of the input
        array, axis=0 by default, or all values in the array if axis=None.
        float64 intermediate and return values are used for integer inputs.
        
        Use masked arrays to ignore any non-finite values in the input or that
        arise in the calculations such as Not a Number and infinity because masked
        arrays automatically mask any non-finite values.
        
        Examples
        --------
        >>> from scipy.stats import gmean
        >>> gmean([1, 4])
        2.0
        >>> gmean([1, 2, 3, 4, 5, 6, 7])
        3.3800151591412964
    
    hhmmeeaann(a, axis=0, dtype=None)
        Calculate the harmonic mean along the specified axis.
        
        That is:  n / (1/x1 + 1/x2 + ... + 1/xn)
        
        Parameters
        ----------
        a : array_like
            Input array, masked array or object that can be converted to an array.
        axis : int or None, optional
            Axis along which the harmonic mean is computed. Default is 0.
            If None, compute over the whole array `a`.
        dtype : dtype, optional
            Type of the returned array and of the accumulator in which the
            elements are summed. If `dtype` is not specified, it defaults to the
            dtype of `a`, unless `a` has an integer `dtype` with a precision less
            than that of the default platform integer. In that case, the default
            platform integer is used.
        
        Returns
        -------
        hmean : ndarray
            see `dtype` parameter above
        
        See Also
        --------
        numpy.mean : Arithmetic average
        numpy.average : Weighted average
        gmean : Geometric mean
        
        Notes
        -----
        The harmonic mean is computed over a single dimension of the input
        array, axis=0 by default, or all values in the array if axis=None.
        float64 intermediate and return values are used for integer inputs.
        
        Use masked arrays to ignore any non-finite values in the input or that
        arise in the calculations such as Not a Number and infinity.
        
        Examples
        --------
        >>> from scipy.stats import hmean
        >>> hmean([1, 4])
        1.6000000000000001
        >>> hmean([1, 2, 3, 4, 5, 6, 7])
        2.6997245179063363
    
    iiqqrr(x, axis=None, rng=(25, 75), scale='raw', nan_policy='propagate', interpolation='linear', keepdims=False)
        Compute the interquartile range of the data along the specified axis.
        
        The interquartile range (IQR) is the difference between the 75th and
        25th percentile of the data. It is a measure of the dispersion
        similar to standard deviation or variance, but is much more robust
        against outliers [2]_.
        
        The ``rng`` parameter allows this function to compute other
        percentile ranges than the actual IQR. For example, setting
        ``rng=(0, 100)`` is equivalent to `numpy.ptp`.
        
        The IQR of an empty array is `np.nan`.
        
        .. versionadded:: 0.18.0
        
        Parameters
        ----------
        x : array_like
            Input array or object that can be converted to an array.
        axis : int or sequence of int, optional
            Axis along which the range is computed. The default is to
            compute the IQR for the entire array.
        rng : Two-element sequence containing floats in range of [0,100] optional
            Percentiles over which to compute the range. Each must be
            between 0 and 100, inclusive. The default is the true IQR:
            `(25, 75)`. The order of the elements is not important.
        scale : scalar or str, optional
            The numerical value of scale will be divided out of the final
            result. The following string values are recognized:
        
              'raw' : No scaling, just return the raw IQR.
              'normal' : Scale by :math:`2 \sqrt{2} erf^{-1}(\frac{1}{2}) \approx 1.349`.
        
            The default is 'raw'. Array-like scale is also allowed, as long
            as it broadcasts correctly to the output such that
            ``out / scale`` is a valid operation. The output dimensions
            depend on the input array, `x`, the `axis` argument, and the
            `keepdims` flag.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate'
            returns nan, 'raise' throws an error, 'omit' performs the
            calculations ignoring nan values. Default is 'propagate'.
        interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}, optional
            Specifies the interpolation method to use when the percentile
            boundaries lie between two data points `i` and `j`:
        
              * 'linear' : `i + (j - i) * fraction`, where `fraction` is the
                  fractional part of the index surrounded by `i` and `j`.
              * 'lower' : `i`.
              * 'higher' : `j`.
              * 'nearest' : `i` or `j` whichever is nearest.
              * 'midpoint' : `(i + j) / 2`.
        
            Default is 'linear'.
        keepdims : bool, optional
            If this is set to `True`, the reduced axes are left in the
            result as dimensions with size one. With this option, the result
            will broadcast correctly against the original array `x`.
        
        Returns
        -------
        iqr : scalar or ndarray
            If ``axis=None``, a scalar is returned. If the input contains
            integers or floats of smaller precision than ``np.float64``, then the
            output data-type is ``np.float64``. Otherwise, the output data-type is
            the same as that of the input.
        
        See Also
        --------
        numpy.std, numpy.var
        
        Examples
        --------
        >>> from scipy.stats import iqr
        >>> x = np.array([[10, 7, 4], [3, 2, 1]])
        >>> x
        array([[10,  7,  4],
               [ 3,  2,  1]])
        >>> iqr(x)
        4.0
        >>> iqr(x, axis=0)
        array([ 3.5,  2.5,  1.5])
        >>> iqr(x, axis=1)
        array([ 3.,  1.])
        >>> iqr(x, axis=1, keepdims=True)
        array([[ 3.],
               [ 1.]])
        
        Notes
        -----
        This function is heavily dependent on the version of `numpy` that is
        installed. Versions greater than 1.11.0b3 are highly recommended, as they
        include a number of enhancements and fixes to `numpy.percentile` and
        `numpy.nanpercentile` that affect the operation of this function. The
        following modifications apply:
        
        Below 1.10.0 : `nan_policy` is poorly defined.
            The default behavior of `numpy.percentile` is used for 'propagate'. This
            is a hybrid of 'omit' and 'propagate' that mostly yields a skewed
            version of 'omit' since NaNs are sorted to the end of the data. A
            warning is raised if there are NaNs in the data.
        Below 1.9.0: `numpy.nanpercentile` does not exist.
            This means that `numpy.percentile` is used regardless of `nan_policy`
            and a warning is issued. See previous item for a description of the
            behavior.
        Below 1.9.0: `keepdims` and `interpolation` are not supported.
            The keywords get ignored with a warning if supplied with non-default
            values. However, multiple axes are still supported.
        
        References
        ----------
        .. [1] "Interquartile range" https://en.wikipedia.org/wiki/Interquartile_range
        .. [2] "Robust measures of scale" https://en.wikipedia.org/wiki/Robust_measures_of_scale
        .. [3] "Quantile" https://en.wikipedia.org/wiki/Quantile
    
    iitteemmffrreeqq(*args, **kwds)
        `itemfreq` is deprecated!
        `itemfreq` is deprecated and will be removed in a future version. Use instead `np.unique(..., return_counts=True)`
        
        
            Return a 2-D array of item frequencies.
        
            Parameters
            ----------
            a : (N,) array_like
                Input array.
        
            Returns
            -------
            itemfreq : (K, 2) ndarray
                A 2-D frequency table.  Column 1 contains sorted, unique values from
                `a`, column 2 contains their respective counts.
        
            Examples
            --------
            >>> from scipy import stats
            >>> a = np.array([1, 1, 5, 0, 1, 2, 2, 0, 1, 4])
            >>> stats.itemfreq(a)
            array([[ 0.,  2.],
                   [ 1.,  4.],
                   [ 2.,  2.],
                   [ 4.,  1.],
                   [ 5.,  1.]])
            >>> np.bincount(a)
            array([2, 4, 2, 0, 1, 1])
        
            >>> stats.itemfreq(a/10.)
            array([[ 0. ,  2. ],
                   [ 0.1,  4. ],
                   [ 0.2,  2. ],
                   [ 0.4,  1. ],
                   [ 0.5,  1. ]])
    
    jjaarrqquuee__bbeerraa(x)
        Perform the Jarque-Bera goodness of fit test on sample data.
        
        The Jarque-Bera test tests whether the sample data has the skewness and
        kurtosis matching a normal distribution.
        
        Note that this test only works for a large enough number of data samples
        (>2000) as the test statistic asymptotically has a Chi-squared distribution
        with 2 degrees of freedom.
        
        Parameters
        ----------
        x : array_like
            Observations of a random variable.
        
        Returns
        -------
        jb_value : float
            The test statistic.
        p : float
            The p-value for the hypothesis test.
        
        References
        ----------
        .. [1] Jarque, C. and Bera, A. (1980) "Efficient tests for normality,
               homoscedasticity and serial independence of regression residuals",
               6 Econometric Letters 255-259.
        
        Examples
        --------
        >>> from scipy import stats
        >>> np.random.seed(987654321)
        >>> x = np.random.normal(0, 1, 100000)
        >>> y = np.random.rayleigh(1, 100000)
        >>> stats.jarque_bera(x)
        (4.7165707989581342, 0.09458225503041906)
        >>> stats.jarque_bera(y)
        (6713.7098548143422, 0.0)
    
    kkeennddaallllttaauu(x, y, initial_lexsort=None, nan_policy='propagate')
        Calculate Kendall's tau, a correlation measure for ordinal data.
        
        Kendall's tau is a measure of the correspondence between two rankings.
        Values close to 1 indicate strong agreement, values close to -1 indicate
        strong disagreement.  This is the 1945 "tau-b" version of Kendall's
        tau [2]_, which can account for ties and which reduces to the 1938 "tau-a"
        version [1]_ in absence of ties.
        
        Parameters
        ----------
        x, y : array_like
            Arrays of rankings, of the same shape. If arrays are not 1-D, they will
            be flattened to 1-D.
        initial_lexsort : bool, optional
            Unused (deprecated).
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'. Note that if the input contains nan
            'omit' delegates to mstats_basic.kendalltau(), which has a different
            implementation.
        
        Returns
        -------
        correlation : float
           The tau statistic.
        pvalue : float
           The two-sided p-value for a hypothesis test whose null hypothesis is
           an absence of association, tau = 0.
        
        See also
        --------
        spearmanr : Calculates a Spearman rank-order correlation coefficient.
        theilslopes : Computes the Theil-Sen estimator for a set of points (x, y).
        weightedtau : Computes a weighted version of Kendall's tau.
        
        Notes
        -----
        The definition of Kendall's tau that is used is [2]_::
        
          tau = (P - Q) / sqrt((P + Q + T) * (P + Q + U))
        
        where P is the number of concordant pairs, Q the number of discordant
        pairs, T the number of ties only in `x`, and U the number of ties only in
        `y`.  If a tie occurs for the same pair in both `x` and `y`, it is not
        added to either T or U.
        
        References
        ----------
        .. [1] Maurice G. Kendall, "A New Measure of Rank Correlation", Biometrika
               Vol. 30, No. 1/2, pp. 81-93, 1938.
        .. [2] Maurice G. Kendall, "The treatment of ties in ranking problems",
               Biometrika Vol. 33, No. 3, pp. 239-251. 1945.
        .. [3] Gottfried E. Noether, "Elements of Nonparametric Statistics", John
               Wiley & Sons, 1967.
        .. [4] Peter M. Fenwick, "A new data structure for cumulative frequency
               tables", Software: Practice and Experience, Vol. 24, No. 3,
               pp. 327-336, 1994.
        
        Examples
        --------
        >>> from scipy import stats
        >>> x1 = [12, 2, 1, 12, 2]
        >>> x2 = [1, 4, 7, 1, 0]
        >>> tau, p_value = stats.kendalltau(x1, x2)
        >>> tau
        -0.47140452079103173
        >>> p_value
        0.2827454599327748
    
    kkrruusskkaall(*args, **kwargs)
        Compute the Kruskal-Wallis H-test for independent samples
        
        The Kruskal-Wallis H-test tests the null hypothesis that the population
        median of all of the groups are equal.  It is a non-parametric version of
        ANOVA.  The test works on 2 or more independent samples, which may have
        different sizes.  Note that rejecting the null hypothesis does not
        indicate which of the groups differs.  Post-hoc comparisons between
        groups are required to determine which groups are different.
        
        Parameters
        ----------
        sample1, sample2, ... : array_like
           Two or more arrays with the sample measurements can be given as
           arguments.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        statistic : float
           The Kruskal-Wallis H statistic, corrected for ties
        pvalue : float
           The p-value for the test using the assumption that H has a chi
           square distribution
        
        See Also
        --------
        f_oneway : 1-way ANOVA
        mannwhitneyu : Mann-Whitney rank test on two samples.
        friedmanchisquare : Friedman test for repeated measurements
        
        Notes
        -----
        Due to the assumption that H has a chi square distribution, the number
        of samples in each group must not be too small.  A typical rule is
        that each sample must have at least 5 measurements.
        
        References
        ----------
        .. [1] W. H. Kruskal & W. W. Wallis, "Use of Ranks in
           One-Criterion Variance Analysis", Journal of the American Statistical
           Association, Vol. 47, Issue 260, pp. 583-621, 1952.
        .. [2] http://en.wikipedia.org/wiki/Kruskal-Wallis_one-way_analysis_of_variance
        
        Examples
        --------
        >>> from scipy import stats
        >>> x = [1, 3, 5, 7, 9]
        >>> y = [2, 4, 6, 8, 10]
        >>> stats.kruskal(x, y)
        KruskalResult(statistic=0.2727272727272734, pvalue=0.6015081344405895)
        
        >>> x = [1, 1, 1]
        >>> y = [2, 2, 2]
        >>> z = [2, 2]
        >>> stats.kruskal(x, y, z)
        KruskalResult(statistic=7.0, pvalue=0.0301973834223185)
    
    kkss__22ssaammpp(data1, data2)
        Compute the Kolmogorov-Smirnov statistic on 2 samples.
        
        This is a two-sided test for the null hypothesis that 2 independent samples
        are drawn from the same continuous distribution.
        
        Parameters
        ----------
        data1, data2 : sequence of 1-D ndarrays
            two arrays of sample observations assumed to be drawn from a continuous
            distribution, sample sizes can be different
        
        Returns
        -------
        statistic : float
            KS statistic
        pvalue : float
            two-tailed p-value
        
        Notes
        -----
        This tests whether 2 samples are drawn from the same distribution. Note
        that, like in the case of the one-sample K-S test, the distribution is
        assumed to be continuous.
        
        This is the two-sided test, one-sided tests are not implemented.
        The test uses the two-sided asymptotic Kolmogorov-Smirnov distribution.
        
        If the K-S statistic is small or the p-value is high, then we cannot
        reject the hypothesis that the distributions of the two samples
        are the same.
        
        Examples
        --------
        >>> from scipy import stats
        >>> np.random.seed(12345678)  #fix random seed to get the same result
        >>> n1 = 200  # size of first sample
        >>> n2 = 300  # size of second sample
        
        For a different distribution, we can reject the null hypothesis since the
        pvalue is below 1%:
        
        >>> rvs1 = stats.norm.rvs(size=n1, loc=0., scale=1)
        >>> rvs2 = stats.norm.rvs(size=n2, loc=0.5, scale=1.5)
        >>> stats.ks_2samp(rvs1, rvs2)
        (0.20833333333333337, 4.6674975515806989e-005)
        
        For a slightly different distribution, we cannot reject the null hypothesis
        at a 10% or lower alpha since the p-value at 0.144 is higher than 10%
        
        >>> rvs3 = stats.norm.rvs(size=n2, loc=0.01, scale=1.0)
        >>> stats.ks_2samp(rvs1, rvs3)
        (0.10333333333333333, 0.14498781825751686)
        
        For an identical distribution, we cannot reject the null hypothesis since
        the p-value is high, 41%:
        
        >>> rvs4 = stats.norm.rvs(size=n2, loc=0.0, scale=1.0)
        >>> stats.ks_2samp(rvs1, rvs4)
        (0.07999999999999996, 0.41126949729859719)
    
    kkssttaatt(data, n=2)
        Return the nth k-statistic (1<=n<=4 so far).
        
        The nth k-statistic k_n is the unique symmetric unbiased estimator of the
        nth cumulant kappa_n.
        
        Parameters
        ----------
        data : array_like
            Input array. Note that n-D input gets flattened.
        n : int, {1, 2, 3, 4}, optional
            Default is equal to 2.
        
        Returns
        -------
        kstat : float
            The nth k-statistic.
        
        See Also
        --------
        kstatvar: Returns an unbiased estimator of the variance of the k-statistic.
        moment: Returns the n-th central moment about the mean for a sample.
        
        Notes
        -----
        For a sample size n, the first few k-statistics are given by:
        
        .. math::
        
            k_{1} = \mu
            k_{2} = \frac{n}{n-1} m_{2}
            k_{3} = \frac{ n^{2} } {(n-1) (n-2)} m_{3}
            k_{4} = \frac{ n^{2} [(n + 1)m_{4} - 3(n - 1) m^2_{2}]} {(n-1) (n-2) (n-3)}
        
        where :math:`\mu` is the sample mean, :math:`m_2` is the sample
        variance, and :math:`m_i` is the i-th sample central moment.
        
        References
        ----------
        http://mathworld.wolfram.com/k-Statistic.html
        
        http://mathworld.wolfram.com/Cumulant.html
        
        Examples
        --------
        >>> from scipy import stats
        >>> rndm = np.random.RandomState(1234)
        
        As sample size increases, n-th moment and n-th k-statistic converge to the
        same number (although they aren't identical). In the case of the normal
        distribution, they converge to zero.
        
        >>> for n in [2, 3, 4, 5, 6, 7]:
        ...     x = rndm.normal(size=10**n)
        ...     m, k = stats.moment(x, 3), stats.kstat(x, 3)
        ...     print("%.3g %.3g %.3g" % (m, k, m-k))
        -0.631 -0.651 0.0194
        0.0282 0.0283 -8.49e-05
        -0.0454 -0.0454 1.36e-05
        7.53e-05 7.53e-05 -2.26e-09
        0.00166 0.00166 -4.99e-09
        -2.88e-06 -2.88e-06 8.63e-13
    
    kkssttaattvvaarr(data, n=2)
        Returns an unbiased estimator of the variance of the k-statistic.
        
        See `kstat` for more details of the k-statistic.
        
        Parameters
        ----------
        data : array_like
            Input array. Note that n-D input gets flattened.
        n : int, {1, 2}, optional
            Default is equal to 2.
        
        Returns
        -------
        kstatvar : float
            The nth k-statistic variance.
        
        See Also
        --------
        kstat: Returns the n-th k-statistic.
        moment: Returns the n-th central moment about the mean for a sample.
        
        Notes
        -----
        The variances of the first few k-statistics are given by:
        
        .. math::
        
            var(k_{1}) = \frac{\kappa^2}{n}
            var(k_{2}) = \frac{\kappa^4}{n} + \frac{2\kappa^2_{2}}{n - 1}
            var(k_{3}) = \frac{\kappa^6}{n} + \frac{9 \kappa_2 \kappa_4}{n - 1} +
                         \frac{9 \kappa^2_{3}}{n - 1} +
                         \frac{6 n \kappa^3_{2}}{(n-1) (n-2)}
            var(k_{4}) = \frac{\kappa^8}{n} + \frac{16 \kappa_2 \kappa_6}{n - 1} +
                         \frac{48 \kappa_{3} \kappa_5}{n - 1} +
                         \frac{34 \kappa^2_{4}}{n-1} + \frac{72 n \kappa^2_{2} \kappa_4}{(n - 1) (n - 2)} +
                         \frac{144 n \kappa_{2} \kappa^2_{3}}{(n - 1) (n - 2)} +
                         \frac{24 (n + 1) n \kappa^4_{2}}{(n - 1) (n - 2) (n - 3)}
    
    kksstteesstt(rvs, cdf, args=(), N=20, alternative='two-sided', mode='approx')
        Perform the Kolmogorov-Smirnov test for goodness of fit.
        
        This performs a test of the distribution G(x) of an observed
        random variable against a given distribution F(x). Under the null
        hypothesis the two distributions are identical, G(x)=F(x). The
        alternative hypothesis can be either 'two-sided' (default), 'less'
        or 'greater'. The KS test is only valid for continuous distributions.
        
        Parameters
        ----------
        rvs : str, array or callable
            If a string, it should be the name of a distribution in `scipy.stats`.
            If an array, it should be a 1-D array of observations of random
            variables.
            If a callable, it should be a function to generate random variables;
            it is required to have a keyword argument `size`.
        cdf : str or callable
            If a string, it should be the name of a distribution in `scipy.stats`.
            If `rvs` is a string then `cdf` can be False or the same as `rvs`.
            If a callable, that callable is used to calculate the cdf.
        args : tuple, sequence, optional
            Distribution parameters, used if `rvs` or `cdf` are strings.
        N : int, optional
            Sample size if `rvs` is string or callable.  Default is 20.
        alternative : {'two-sided', 'less','greater'}, optional
            Defines the alternative hypothesis (see explanation above).
            Default is 'two-sided'.
        mode : 'approx' (default) or 'asymp', optional
            Defines the distribution used for calculating the p-value.
        
              - 'approx' : use approximation to exact distribution of test statistic
              - 'asymp' : use asymptotic distribution of test statistic
        
        Returns
        -------
        statistic : float
            KS test statistic, either D, D+ or D-.
        pvalue :  float
            One-tailed or two-tailed p-value.
        
        Notes
        -----
        In the one-sided test, the alternative is that the empirical
        cumulative distribution function of the random variable is "less"
        or "greater" than the cumulative distribution function F(x) of the
        hypothesis, ``G(x)<=F(x)``, resp. ``G(x)>=F(x)``.
        
        Examples
        --------
        >>> from scipy import stats
        
        >>> x = np.linspace(-15, 15, 9)
        >>> stats.kstest(x, 'norm')
        (0.44435602715924361, 0.038850142705171065)
        
        >>> np.random.seed(987654321) # set random seed to get the same result
        >>> stats.kstest('norm', False, N=100)
        (0.058352892479417884, 0.88531190944151261)
        
        The above lines are equivalent to:
        
        >>> np.random.seed(987654321)
        >>> stats.kstest(stats.norm.rvs(size=100), 'norm')
        (0.058352892479417884, 0.88531190944151261)
        
        *Test against one-sided alternative hypothesis*
        
        Shift distribution to larger values, so that ``cdf_dgp(x) < norm.cdf(x)``:
        
        >>> np.random.seed(987654321)
        >>> x = stats.norm.rvs(loc=0.2, size=100)
        >>> stats.kstest(x,'norm', alternative = 'less')
        (0.12464329735846891, 0.040989164077641749)
        
        Reject equal distribution against alternative hypothesis: less
        
        >>> stats.kstest(x,'norm', alternative = 'greater')
        (0.0072115233216311081, 0.98531158590396395)
        
        Don't reject equal distribution against alternative hypothesis: greater
        
        >>> stats.kstest(x,'norm', mode='asymp')
        (0.12464329735846891, 0.08944488871182088)
        
        *Testing t distributed random variables against normal distribution*
        
        With 100 degrees of freedom the t distribution looks close to the normal
        distribution, and the K-S test does not reject the hypothesis that the
        sample came from the normal distribution:
        
        >>> np.random.seed(987654321)
        >>> stats.kstest(stats.t.rvs(100,size=100),'norm')
        (0.072018929165471257, 0.67630062862479168)
        
        With 3 degrees of freedom the t distribution looks sufficiently different
        from the normal distribution, that we can reject the hypothesis that the
        sample came from the normal distribution at the 10% level:
        
        >>> np.random.seed(987654321)
        >>> stats.kstest(stats.t.rvs(3,size=100),'norm')
        (0.131016895759829, 0.058826222555312224)
    
    kkuurrttoossiiss(a, axis=0, fisher=True, bias=True, nan_policy='propagate')
        Compute the kurtosis (Fisher or Pearson) of a dataset.
        
        Kurtosis is the fourth central moment divided by the square of the
        variance. If Fisher's definition is used, then 3.0 is subtracted from
        the result to give 0.0 for a normal distribution.
        
        If bias is False then the kurtosis is calculated using k statistics to
        eliminate bias coming from biased moment estimators
        
        Use `kurtosistest` to see if result is close enough to normal.
        
        Parameters
        ----------
        a : array
            data for which the kurtosis is calculated
        axis : int or None, optional
            Axis along which the kurtosis is calculated. Default is 0.
            If None, compute over the whole array `a`.
        fisher : bool, optional
            If True, Fisher's definition is used (normal ==> 0.0). If False,
            Pearson's definition is used (normal ==> 3.0).
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        kurtosis : array
            The kurtosis of values along an axis. If all values are equal,
            return -3 for Fisher's definition and 0 for Pearson's definition.
        
        References
        ----------
        .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
           Probability and Statistics Tables and Formulae. Chapman & Hall: New
           York. 2000.
        
        Examples
        --------
        >>> from scipy.stats import kurtosis
        >>> kurtosis([1, 2, 3, 4, 5])
        -1.3
    
    kkuurrttoossiisstteesstt(a, axis=0, nan_policy='propagate')
        Test whether a dataset has normal kurtosis.
        
        This function tests the null hypothesis that the kurtosis
        of the population from which the sample was drawn is that
        of the normal distribution: ``kurtosis = 3(n-1)/(n+1)``.
        
        Parameters
        ----------
        a : array
            array of the sample data
        axis : int or None, optional
           Axis along which to compute test. Default is 0. If None,
           compute over the whole array `a`.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        statistic : float
            The computed z-score for this test.
        pvalue : float
            The 2-sided p-value for the hypothesis test
        
        Notes
        -----
        Valid only for n>20.  The Z-score is set to 0 for bad entries.
        This function uses the method described in [1]_.
        
        References
        ----------
        .. [1] see e.g. F. J. Anscombe, W. J. Glynn, "Distribution of the kurtosis
           statistic b2 for normal samples", Biometrika, vol. 70, pp. 227-234, 1983.
        
        Examples
        --------
        >>> from scipy.stats import kurtosistest
        >>> kurtosistest(list(range(20)))
        KurtosistestResult(statistic=-1.7058104152122062, pvalue=0.08804338332528348)
        
        >>> np.random.seed(28041990)
        >>> s = np.random.normal(0, 1, 1000)
        >>> kurtosistest(s)
        KurtosistestResult(statistic=1.2317590987707365, pvalue=0.21803908613450895)
    
    lleevveennee(*args, **kwds)
        Perform Levene test for equal variances.
        
        The Levene test tests the null hypothesis that all input samples
        are from populations with equal variances.  Levene's test is an
        alternative to Bartlett's test `bartlett` in the case where
        there are significant deviations from normality.
        
        Parameters
        ----------
        sample1, sample2, ... : array_like
            The sample data, possibly with different lengths
        center : {'mean', 'median', 'trimmed'}, optional
            Which function of the data to use in the test.  The default
            is 'median'.
        proportiontocut : float, optional
            When `center` is 'trimmed', this gives the proportion of data points
            to cut from each end. (See `scipy.stats.trim_mean`.)
            Default is 0.05.
        
        Returns
        -------
        statistic : float
            The test statistic.
        pvalue : float
            The p-value for the test.
        
        Notes
        -----
        Three variations of Levene's test are possible.  The possibilities
        and their recommended usages are:
        
          * 'median' : Recommended for skewed (non-normal) distributions>
          * 'mean' : Recommended for symmetric, moderate-tailed distributions.
          * 'trimmed' : Recommended for heavy-tailed distributions.
        
        References
        ----------
        .. [1]  http://www.itl.nist.gov/div898/handbook/eda/section3/eda35a.htm
        .. [2]   Levene, H. (1960). In Contributions to Probability and Statistics:
                   Essays in Honor of Harold Hotelling, I. Olkin et al. eds.,
                   Stanford University Press, pp. 278-292.
        .. [3]  Brown, M. B. and Forsythe, A. B. (1974), Journal of the American
                  Statistical Association, 69, 364-367
    
    lliinnrreeggrreessss(x, y=None)
        Calculate a linear least-squares regression for two sets of measurements.
        
        Parameters
        ----------
        x, y : array_like
            Two sets of measurements.  Both arrays should have the same length.
            If only x is given (and y=None), then it must be a two-dimensional
            array where one dimension has length 2.  The two sets of measurements
            are then found by splitting the array along the length-2 dimension.
        
        Returns
        -------
        slope : float
            slope of the regression line
        intercept : float
            intercept of the regression line
        rvalue : float
            correlation coefficient
        pvalue : float
            two-sided p-value for a hypothesis test whose null hypothesis is
            that the slope is zero, using Wald Test with t-distribution of
            the test statistic.
        stderr : float
            Standard error of the estimated gradient.
        
        See also
        --------
        :func:`scipy.optimize.curve_fit` : Use non-linear
         least squares to fit a function to data.
        :func:`scipy.optimize.leastsq` : Minimize the sum of
         squares of a set of equations.
        
        Examples
        --------
        >>> import matplotlib.pyplot as plt
        >>> from scipy import stats
        >>> np.random.seed(12345678)
        >>> x = np.random.random(10)
        >>> y = np.random.random(10)
        >>> slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)
        
        To get coefficient of determination (r_squared)
        
        >>> print("r-squared:", r_value**2)
        r-squared: 0.08040226853902833
        
        Plot the data along with the fitted line
        
        >>> plt.plot(x, y, 'o', label='original data')
        >>> plt.plot(x, intercept + slope*x, 'r', label='fitted line')
        >>> plt.legend()
        >>> plt.show()
    
    mmaannnnwwhhiittnneeyyuu(x, y, use_continuity=True, alternative=None)
        Compute the Mann-Whitney rank test on samples x and y.
        
        Parameters
        ----------
        x, y : array_like
            Array of samples, should be one-dimensional.
        use_continuity : bool, optional
                Whether a continuity correction (1/2.) should be taken into
                account. Default is True.
        alternative : None (deprecated), 'less', 'two-sided', or 'greater'
                Whether to get the p-value for the one-sided hypothesis ('less'
                or 'greater') or for the two-sided hypothesis ('two-sided').
                Defaults to None, which results in a p-value half the size of
                the 'two-sided' p-value and a different U statistic. The
                default behavior is not the same as using 'less' or 'greater':
                it only exists for backward compatibility and is deprecated.
        
        Returns
        -------
        statistic : float
            The Mann-Whitney U statistic, equal to min(U for x, U for y) if
            `alternative` is equal to None (deprecated; exists for backward
            compatibility), and U for y otherwise.
        pvalue : float
            p-value assuming an asymptotic normal distribution. One-sided or
            two-sided, depending on the choice of `alternative`.
        
        Notes
        -----
        Use only when the number of observation in each sample is > 20 and
        you have 2 independent samples of ranks. Mann-Whitney U is
        significant if the u-obtained is LESS THAN or equal to the critical
        value of U.
        
        This test corrects for ties and by default uses a continuity correction.
        
        References
        ----------
        .. [1] https://en.wikipedia.org/wiki/Mann-Whitney_U_test
        
        .. [2] H.B. Mann and D.R. Whitney, "On a Test of Whether one of Two Random
               Variables is Stochastically Larger than the Other," The Annals of
               Mathematical Statistics, vol. 18, no. 1, pp. 50-60, 1947.
    
    mmeeddiiaann__tteesstt(*args, **kwds)
        Mood's median test.
        
        Test that two or more samples come from populations with the same median.
        
        Let ``n = len(args)`` be the number of samples.  The "grand median" of
        all the data is computed, and a contingency table is formed by
        classifying the values in each sample as being above or below the grand
        median.  The contingency table, along with `correction` and `lambda_`,
        are passed to `scipy.stats.chi2_contingency` to compute the test statistic
        and p-value.
        
        Parameters
        ----------
        sample1, sample2, ... : array_like
            The set of samples.  There must be at least two samples.
            Each sample must be a one-dimensional sequence containing at least
            one value.  The samples are not required to have the same length.
        ties : str, optional
            Determines how values equal to the grand median are classified in
            the contingency table.  The string must be one of::
        
                "below":
                    Values equal to the grand median are counted as "below".
                "above":
                    Values equal to the grand median are counted as "above".
                "ignore":
                    Values equal to the grand median are not counted.
        
            The default is "below".
        correction : bool, optional
            If True, *and* there are just two samples, apply Yates' correction
            for continuity when computing the test statistic associated with
            the contingency table.  Default is True.
        lambda_ : float or str, optional.
            By default, the statistic computed in this test is Pearson's
            chi-squared statistic.  `lambda_` allows a statistic from the
            Cressie-Read power divergence family to be used instead.  See
            `power_divergence` for details.
            Default is 1 (Pearson's chi-squared statistic).
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        stat : float
            The test statistic.  The statistic that is returned is determined by
            `lambda_`.  The default is Pearson's chi-squared statistic.
        p : float
            The p-value of the test.
        m : float
            The grand median.
        table : ndarray
            The contingency table.  The shape of the table is (2, n), where
            n is the number of samples.  The first row holds the counts of the
            values above the grand median, and the second row holds the counts
            of the values below the grand median.  The table allows further
            analysis with, for example, `scipy.stats.chi2_contingency`, or with
            `scipy.stats.fisher_exact` if there are two samples, without having
            to recompute the table.  If ``nan_policy`` is "propagate" and there
            are nans in the input, the return value for ``table`` is ``None``.
        
        See Also
        --------
        kruskal : Compute the Kruskal-Wallis H-test for independent samples.
        mannwhitneyu : Computes the Mann-Whitney rank test on samples x and y.
        
        Notes
        -----
        .. versionadded:: 0.15.0
        
        References
        ----------
        .. [1] Mood, A. M., Introduction to the Theory of Statistics. McGraw-Hill
            (1950), pp. 394-399.
        .. [2] Zar, J. H., Biostatistical Analysis, 5th ed. Prentice Hall (2010).
            See Sections 8.12 and 10.15.
        
        Examples
        --------
        A biologist runs an experiment in which there are three groups of plants.
        Group 1 has 16 plants, group 2 has 15 plants, and group 3 has 17 plants.
        Each plant produces a number of seeds.  The seed counts for each group
        are::
        
            Group 1: 10 14 14 18 20 22 24 25 31 31 32 39 43 43 48 49
            Group 2: 28 30 31 33 34 35 36 40 44 55 57 61 91 92 99
            Group 3:  0  3  9 22 23 25 25 33 34 34 40 45 46 48 62 67 84
        
        The following code applies Mood's median test to these samples.
        
        >>> g1 = [10, 14, 14, 18, 20, 22, 24, 25, 31, 31, 32, 39, 43, 43, 48, 49]
        >>> g2 = [28, 30, 31, 33, 34, 35, 36, 40, 44, 55, 57, 61, 91, 92, 99]
        >>> g3 = [0, 3, 9, 22, 23, 25, 25, 33, 34, 34, 40, 45, 46, 48, 62, 67, 84]
        >>> from scipy.stats import median_test
        >>> stat, p, med, tbl = median_test(g1, g2, g3)
        
        The median is
        
        >>> med
        34.0
        
        and the contingency table is
        
        >>> tbl
        array([[ 5, 10,  7],
               [11,  5, 10]])
        
        `p` is too large to conclude that the medians are not the same:
        
        >>> p
        0.12609082774093244
        
        The "G-test" can be performed by passing ``lambda_="log-likelihood"`` to
        `median_test`.
        
        >>> g, p, med, tbl = median_test(g1, g2, g3, lambda_="log-likelihood")
        >>> p
        0.12224779737117837
        
        The median occurs several times in the data, so we'll get a different
        result if, for example, ``ties="above"`` is used:
        
        >>> stat, p, med, tbl = median_test(g1, g2, g3, ties="above")
        >>> p
        0.063873276069553273
        
        >>> tbl
        array([[ 5, 11,  9],
               [11,  4,  8]])
        
        This example demonstrates that if the data set is not large and there
        are values equal to the median, the p-value can be sensitive to the
        choice of `ties`.
    
    mmooddee(a, axis=0, nan_policy='propagate')
        Return an array of the modal (most common) value in the passed array.
        
        If there is more than one such value, only the smallest is returned.
        The bin-count for the modal bins is also returned.
        
        Parameters
        ----------
        a : array_like
            n-dimensional array of which to find mode(s).
        axis : int or None, optional
            Axis along which to operate. Default is 0. If None, compute over
            the whole array `a`.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        mode : ndarray
            Array of modal values.
        count : ndarray
            Array of counts for each mode.
        
        Examples
        --------
        >>> a = np.array([[6, 8, 3, 0],
        ...               [3, 2, 1, 7],
        ...               [8, 1, 8, 4],
        ...               [5, 3, 0, 5],
        ...               [4, 7, 5, 9]])
        >>> from scipy import stats
        >>> stats.mode(a)
        (array([[3, 1, 0, 0]]), array([[1, 1, 1, 1]]))
        
        To get mode of whole array, specify ``axis=None``:
        
        >>> stats.mode(a, axis=None)
        (array([3]), array([3]))
    
    mmoommeenntt(a, moment=1, axis=0, nan_policy='propagate')
        Calculate the nth moment about the mean for a sample.
        
        A moment is a specific quantitative measure of the shape of a set of
        points. It is often used to calculate coefficients of skewness and kurtosis
        due to its close relationship with them.
        
        
        Parameters
        ----------
        a : array_like
           data
        moment : int or array_like of ints, optional
           order of central moment that is returned. Default is 1.
        axis : int or None, optional
           Axis along which the central moment is computed. Default is 0.
           If None, compute over the whole array `a`.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        n-th central moment : ndarray or float
           The appropriate moment along the given axis or over all values if axis
           is None. The denominator for the moment calculation is the number of
           observations, no degrees of freedom correction is done.
        
        See also
        --------
        kurtosis, skew, describe
        
        Notes
        -----
        The k-th central moment of a data sample is:
        
        .. math::
        
            m_k = \frac{1}{n} \sum_{i = 1}^n (x_i - \bar{x})^k
        
        Where n is the number of samples and x-bar is the mean. This function uses
        exponentiation by squares [1]_ for efficiency.
        
        References
        ----------
        .. [1] http://eli.thegreenplace.net/2009/03/21/efficient-integer-exponentiation-algorithms
        
        Examples
        --------
        >>> from scipy.stats import moment
        >>> moment([1, 2, 3, 4, 5], moment=1)
        0.0
        >>> moment([1, 2, 3, 4, 5], moment=2)
        2.0
    
    mmoooodd(x, y, axis=0)
        Perform Mood's test for equal scale parameters.
        
        Mood's two-sample test for scale parameters is a non-parametric
        test for the null hypothesis that two samples are drawn from the
        same distribution with the same scale parameter.
        
        Parameters
        ----------
        x, y : array_like
            Arrays of sample data.
        axis : int, optional
            The axis along which the samples are tested.  `x` and `y` can be of
            different length along `axis`.
            If `axis` is None, `x` and `y` are flattened and the test is done on
            all values in the flattened arrays.
        
        Returns
        -------
        z : scalar or ndarray
            The z-score for the hypothesis test.  For 1-D inputs a scalar is
            returned.
        p-value : scalar ndarray
            The p-value for the hypothesis test.
        
        See Also
        --------
        fligner : A non-parametric test for the equality of k variances
        ansari : A non-parametric test for the equality of 2 variances
        bartlett : A parametric test for equality of k variances in normal samples
        levene : A parametric test for equality of k variances
        
        Notes
        -----
        The data are assumed to be drawn from probability distributions ``f(x)``
        and ``f(x/s) / s`` respectively, for some probability density function f.
        The null hypothesis is that ``s == 1``.
        
        For multi-dimensional arrays, if the inputs are of shapes
        ``(n0, n1, n2, n3)``  and ``(n0, m1, n2, n3)``, then if ``axis=1``, the
        resulting z and p values will have shape ``(n0, n2, n3)``.  Note that
        ``n1`` and ``m1`` don't have to be equal, but the other dimensions do.
        
        Examples
        --------
        >>> from scipy import stats
        >>> np.random.seed(1234)
        >>> x2 = np.random.randn(2, 45, 6, 7)
        >>> x1 = np.random.randn(2, 30, 6, 7)
        >>> z, p = stats.mood(x1, x2, axis=1)
        >>> p.shape
        (2, 6, 7)
        
        Find the number of points where the difference in scale is not significant:
        
        >>> (p > 0.1).sum()
        74
        
        Perform the test with different scales:
        
        >>> x1 = np.random.randn(2, 30)
        >>> x2 = np.random.randn(2, 35) * 10.0
        >>> stats.mood(x1, x2, axis=1)
        (array([-5.7178125 , -5.25342163]), array([  1.07904114e-08,   1.49299218e-07]))
    
    mmvvssddiisstt(data)
        'Frozen' distributions for mean, variance, and standard deviation of data.
        
        Parameters
        ----------
        data : array_like
            Input array. Converted to 1-D using ravel.
            Requires 2 or more data-points.
        
        Returns
        -------
        mdist : "frozen" distribution object
            Distribution object representing the mean of the data
        vdist : "frozen" distribution object
            Distribution object representing the variance of the data
        sdist : "frozen" distribution object
            Distribution object representing the standard deviation of the data
        
        See Also
        --------
        bayes_mvs
        
        Notes
        -----
        The return values from ``bayes_mvs(data)`` is equivalent to
        ``tuple((x.mean(), x.interval(0.90)) for x in mvsdist(data))``.
        
        In other words, calling ``<dist>.mean()`` and ``<dist>.interval(0.90)``
        on the three distribution objects returned from this function will give
        the same results that are returned from `bayes_mvs`.
        
        References
        ----------
        T.E. Oliphant, "A Bayesian perspective on estimating mean, variance, and
        standard-deviation from data", http://scholarsarchive.byu.edu/facpub/278,
        2006.
        
        Examples
        --------
        >>> from scipy import stats
        >>> data = [6, 9, 12, 7, 8, 8, 13]
        >>> mean, var, std = stats.mvsdist(data)
        
        We now have frozen distribution objects "mean", "var" and "std" that we can
        examine:
        
        >>> mean.mean()
        9.0
        >>> mean.interval(0.95)
        (6.6120585482655692, 11.387941451734431)
        >>> mean.std()
        1.1952286093343936
    
    nnoorrmmaalltteesstt(a, axis=0, nan_policy='propagate')
        Test whether a sample differs from a normal distribution.
        
        This function tests the null hypothesis that a sample comes
        from a normal distribution.  It is based on D'Agostino and
        Pearson's [1]_, [2]_ test that combines skew and kurtosis to
        produce an omnibus test of normality.
        
        
        Parameters
        ----------
        a : array_like
            The array containing the sample to be tested.
        axis : int or None, optional
            Axis along which to compute test. Default is 0. If None,
            compute over the whole array `a`.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        statistic : float or array
            ``s^2 + k^2``, where ``s`` is the z-score returned by `skewtest` and
            ``k`` is the z-score returned by `kurtosistest`.
        pvalue : float or array
           A 2-sided chi squared probability for the hypothesis test.
        
        References
        ----------
        .. [1] D'Agostino, R. B. (1971), "An omnibus test of normality for
               moderate and large sample size", Biometrika, 58, 341-348
        
        .. [2] D'Agostino, R. and Pearson, E. S. (1973), "Tests for departure from
               normality", Biometrika, 60, 613-622
        
        Examples
        --------
        >>> from scipy import stats
        >>> pts = 1000
        >>> np.random.seed(28041990)
        >>> a = np.random.normal(0, 1, size=pts)
        >>> b = np.random.normal(2, 1, size=pts)
        >>> x = np.concatenate((a, b))
        >>> k2, p = stats.normaltest(x)
        >>> alpha = 1e-3
        >>> print("p = {:g}".format(p))
        p = 3.27207e-11
        >>> if p < alpha:  # null hypothesis: x comes from a normal distribution
        ...     print("The null hypothesis can be rejected")
        ... else:
        ...     print("The null hypothesis cannot be rejected")
        The null hypothesis can be rejected
    
    oobbrriieennttrraannssffoorrmm(*args)
        Compute the O'Brien transform on input data (any number of arrays).
        
        Used to test for homogeneity of variance prior to running one-way stats.
        Each array in ``*args`` is one level of a factor.
        If `f_oneway` is run on the transformed data and found significant,
        the variances are unequal.  From Maxwell and Delaney [1]_, p.112.
        
        Parameters
        ----------
        args : tuple of array_like
            Any number of arrays.
        
        Returns
        -------
        obrientransform : ndarray
            Transformed data for use in an ANOVA.  The first dimension
            of the result corresponds to the sequence of transformed
            arrays.  If the arrays given are all 1-D of the same length,
            the return value is a 2-D array; otherwise it is a 1-D array
            of type object, with each element being an ndarray.
        
        References
        ----------
        .. [1] S. E. Maxwell and H. D. Delaney, "Designing Experiments and
               Analyzing Data: A Model Comparison Perspective", Wadsworth, 1990.
        
        Examples
        --------
        We'll test the following data sets for differences in their variance.
        
        >>> x = [10, 11, 13, 9, 7, 12, 12, 9, 10]
        >>> y = [13, 21, 5, 10, 8, 14, 10, 12, 7, 15]
        
        Apply the O'Brien transform to the data.
        
        >>> from scipy.stats import obrientransform
        >>> tx, ty = obrientransform(x, y)
        
        Use `scipy.stats.f_oneway` to apply a one-way ANOVA test to the
        transformed data.
        
        >>> from scipy.stats import f_oneway
        >>> F, p = f_oneway(tx, ty)
        >>> p
        0.1314139477040335
        
        If we require that ``p < 0.05`` for significance, we cannot conclude
        that the variances are different.
    
    ppeeaarrssoonnrr(x, y)
        Calculate a Pearson correlation coefficient and the p-value for testing
        non-correlation.
        
        The Pearson correlation coefficient measures the linear relationship
        between two datasets. Strictly speaking, Pearson's correlation requires
        that each dataset be normally distributed, and not necessarily zero-mean.
        Like other correlation coefficients, this one varies between -1 and +1
        with 0 implying no correlation. Correlations of -1 or +1 imply an exact
        linear relationship. Positive correlations imply that as x increases, so
        does y. Negative correlations imply that as x increases, y decreases.
        
        The p-value roughly indicates the probability of an uncorrelated system
        producing datasets that have a Pearson correlation at least as extreme
        as the one computed from these datasets. The p-values are not entirely
        reliable but are probably reasonable for datasets larger than 500 or so.
        
        Parameters
        ----------
        x : (N,) array_like
            Input
        y : (N,) array_like
            Input
        
        Returns
        -------
        r : float
            Pearson's correlation coefficient
        p-value : float
            2-tailed p-value
        
        Notes
        -----
        
        The correlation coefficient is calculated as follows:
        
        .. math::
        
            r_{pb} = \frac{\sum (x - m_x) (y - m_y)
                           }{\sqrt{\sum (x - m_x)^2 (y - m_y)^2}}
        
        where :math:`m_x` is the mean of the vector :math:`x` and :math:`m_y` is
        the mean of the vector :math:`y`.
        
        
        References
        ----------
        http://www.statsoft.com/textbook/glosp.html#Pearson%20Correlation
        
        Examples
        --------
        >>> from scipy import stats
        >>> a = np.array([0, 0, 0, 1, 1, 1, 1])
        >>> b = np.arange(7)
        >>> stats.pearsonr(a, b)
        (0.8660254037844386, 0.011724811003954654)
        
        >>> stats.pearsonr([1,2,3,4,5], [5,6,7,8,7])
        (0.83205029433784372, 0.080509573298498519)
    
    ppeerrcceennttiilleeooffssccoorree(a, score, kind='rank')
        The percentile rank of a score relative to a list of scores.
        
        A `percentileofscore` of, for example, 80% means that 80% of the
        scores in `a` are below the given score. In the case of gaps or
        ties, the exact definition depends on the optional keyword, `kind`.
        
        Parameters
        ----------
        a : array_like
            Array of scores to which `score` is compared.
        score : int or float
            Score that is compared to the elements in `a`.
        kind : {'rank', 'weak', 'strict', 'mean'}, optional
            This optional parameter specifies the interpretation of the
            resulting score:
        
            - "rank": Average percentage ranking of score.  In case of
                      multiple matches, average the percentage rankings of
                      all matching scores.
            - "weak": This kind corresponds to the definition of a cumulative
                      distribution function.  A percentileofscore of 80%
                      means that 80% of values are less than or equal
                      to the provided score.
            - "strict": Similar to "weak", except that only values that are
                        strictly less than the given score are counted.
            - "mean": The average of the "weak" and "strict" scores, often used in
                      testing.  See
        
                      http://en.wikipedia.org/wiki/Percentile_rank
        
        Returns
        -------
        pcos : float
            Percentile-position of score (0-100) relative to `a`.
        
        See Also
        --------
        numpy.percentile
        
        Examples
        --------
        Three-quarters of the given values lie below a given score:
        
        >>> from scipy import stats
        >>> stats.percentileofscore([1, 2, 3, 4], 3)
        75.0
        
        With multiple matches, note how the scores of the two matches, 0.6
        and 0.8 respectively, are averaged:
        
        >>> stats.percentileofscore([1, 2, 3, 3, 4], 3)
        70.0
        
        Only 2/5 values are strictly less than 3:
        
        >>> stats.percentileofscore([1, 2, 3, 3, 4], 3, kind='strict')
        40.0
        
        But 4/5 values are less than or equal to 3:
        
        >>> stats.percentileofscore([1, 2, 3, 3, 4], 3, kind='weak')
        80.0
        
        The average between the weak and the strict scores is
        
        >>> stats.percentileofscore([1, 2, 3, 3, 4], 3, kind='mean')
        60.0
    
    ppooiinnttbbiisseerriiaallrr(x, y)
        Calculate a point biserial correlation coefficient and its p-value.
        
        The point biserial correlation is used to measure the relationship
        between a binary variable, x, and a continuous variable, y. Like other
        correlation coefficients, this one varies between -1 and +1 with 0
        implying no correlation. Correlations of -1 or +1 imply a determinative
        relationship.
        
        This function uses a shortcut formula but produces the same result as
        `pearsonr`.
        
        Parameters
        ----------
        x : array_like of bools
            Input array.
        y : array_like
            Input array.
        
        Returns
        -------
        correlation : float
            R value
        pvalue : float
            2-tailed p-value
        
        Notes
        -----
        `pointbiserialr` uses a t-test with ``n-1`` degrees of freedom.
        It is equivalent to `pearsonr.`
        
        The value of the point-biserial correlation can be calculated from:
        
        .. math::
        
            r_{pb} = \frac{\overline{Y_{1}} -
                     \overline{Y_{0}}}{s_{y}}\sqrt{\frac{N_{1} N_{2}}{N (N - 1))}}
        
        Where :math:`Y_{0}` and :math:`Y_{1}` are means of the metric
        observations coded 0 and 1 respectively; :math:`N_{0}` and :math:`N_{1}`
        are number of observations coded 0 and 1 respectively; :math:`N` is the
        total number of observations and :math:`s_{y}` is the standard
        deviation of all the metric observations.
        
        A value of :math:`r_{pb}` that is significantly different from zero is
        completely equivalent to a significant difference in means between the two
        groups. Thus, an independent groups t Test with :math:`N-2` degrees of
        freedom may be used to test whether :math:`r_{pb}` is nonzero. The
        relation between the t-statistic for comparing two independent groups and
        :math:`r_{pb}` is given by:
        
        .. math::
        
            t = \sqrt{N - 2}\frac{r_{pb}}{\sqrt{1 - r^{2}_{pb}}}
        
        References
        ----------
        .. [1] J. Lev, "The Point Biserial Coefficient of Correlation", Ann. Math.
               Statist., Vol. 20, no.1, pp. 125-126, 1949.
        
        .. [2] R.F. Tate, "Correlation Between a Discrete and a Continuous
               Variable. Point-Biserial Correlation.", Ann. Math. Statist., Vol. 25,
               np. 3, pp. 603-607, 1954.
        
        .. [3] http://onlinelibrary.wiley.com/doi/10.1002/9781118445112.stat06227/full
        
        Examples
        --------
        >>> from scipy import stats
        >>> a = np.array([0, 0, 0, 1, 1, 1, 1])
        >>> b = np.arange(7)
        >>> stats.pointbiserialr(a, b)
        (0.8660254037844386, 0.011724811003954652)
        >>> stats.pearsonr(a, b)
        (0.86602540378443871, 0.011724811003954626)
        >>> np.corrcoef(a, b)
        array([[ 1.       ,  0.8660254],
               [ 0.8660254,  1.       ]])
    
    ppoowweerr__ddiivveerrggeennccee(f_obs, f_exp=None, ddof=0, axis=0, lambda_=None)
        Cressie-Read power divergence statistic and goodness of fit test.
        
        This function tests the null hypothesis that the categorical data
        has the given frequencies, using the Cressie-Read power divergence
        statistic.
        
        Parameters
        ----------
        f_obs : array_like
            Observed frequencies in each category.
        f_exp : array_like, optional
            Expected frequencies in each category.  By default the categories are
            assumed to be equally likely.
        ddof : int, optional
            "Delta degrees of freedom": adjustment to the degrees of freedom
            for the p-value.  The p-value is computed using a chi-squared
            distribution with ``k - 1 - ddof`` degrees of freedom, where `k`
            is the number of observed frequencies.  The default value of `ddof`
            is 0.
        axis : int or None, optional
            The axis of the broadcast result of `f_obs` and `f_exp` along which to
            apply the test.  If axis is None, all values in `f_obs` are treated
            as a single data set.  Default is 0.
        lambda_ : float or str, optional
            `lambda_` gives the power in the Cressie-Read power divergence
            statistic.  The default is 1.  For convenience, `lambda_` may be
            assigned one of the following strings, in which case the
            corresponding numerical value is used::
        
                String              Value   Description
                "pearson"             1     Pearson's chi-squared statistic.
                                            In this case, the function is
                                            equivalent to `stats.chisquare`.
                "log-likelihood"      0     Log-likelihood ratio. Also known as
                                            the G-test [3]_.
                "freeman-tukey"      -1/2   Freeman-Tukey statistic.
                "mod-log-likelihood" -1     Modified log-likelihood ratio.
                "neyman"             -2     Neyman's statistic.
                "cressie-read"        2/3   The power recommended in [5]_.
        
        Returns
        -------
        statistic : float or ndarray
            The Cressie-Read power divergence test statistic.  The value is
            a float if `axis` is None or if` `f_obs` and `f_exp` are 1-D.
        pvalue : float or ndarray
            The p-value of the test.  The value is a float if `ddof` and the
            return value `stat` are scalars.
        
        See Also
        --------
        chisquare
        
        Notes
        -----
        This test is invalid when the observed or expected frequencies in each
        category are too small.  A typical rule is that all of the observed
        and expected frequencies should be at least 5.
        
        When `lambda_` is less than zero, the formula for the statistic involves
        dividing by `f_obs`, so a warning or error may be generated if any value
        in `f_obs` is 0.
        
        Similarly, a warning or error may be generated if any value in `f_exp` is
        zero when `lambda_` >= 0.
        
        The default degrees of freedom, k-1, are for the case when no parameters
        of the distribution are estimated. If p parameters are estimated by
        efficient maximum likelihood then the correct degrees of freedom are
        k-1-p. If the parameters are estimated in a different way, then the
        dof can be between k-1-p and k-1. However, it is also possible that
        the asymptotic distribution is not a chisquare, in which case this
        test is not appropriate.
        
        This function handles masked arrays.  If an element of `f_obs` or `f_exp`
        is masked, then data at that position is ignored, and does not count
        towards the size of the data set.
        
        .. versionadded:: 0.13.0
        
        References
        ----------
        .. [1] Lowry, Richard.  "Concepts and Applications of Inferential
               Statistics". Chapter 8. http://faculty.vassar.edu/lowry/ch8pt1.html
        .. [2] "Chi-squared test", http://en.wikipedia.org/wiki/Chi-squared_test
        .. [3] "G-test", http://en.wikipedia.org/wiki/G-test
        .. [4] Sokal, R. R. and Rohlf, F. J. "Biometry: the principles and
               practice of statistics in biological research", New York: Freeman
               (1981)
        .. [5] Cressie, N. and Read, T. R. C., "Multinomial Goodness-of-Fit
               Tests", J. Royal Stat. Soc. Series B, Vol. 46, No. 3 (1984),
               pp. 440-464.
        
        Examples
        --------
        
        (See `chisquare` for more examples.)
        
        When just `f_obs` is given, it is assumed that the expected frequencies
        are uniform and given by the mean of the observed frequencies.  Here we
        perform a G-test (i.e. use the log-likelihood ratio statistic):
        
        >>> from scipy.stats import power_divergence
        >>> power_divergence([16, 18, 16, 14, 12, 12], lambda_='log-likelihood')
        (2.006573162632538, 0.84823476779463769)
        
        The expected frequencies can be given with the `f_exp` argument:
        
        >>> power_divergence([16, 18, 16, 14, 12, 12],
        ...                  f_exp=[16, 16, 16, 16, 16, 8],
        ...                  lambda_='log-likelihood')
        (3.3281031458963746, 0.6495419288047497)
        
        When `f_obs` is 2-D, by default the test is applied to each column.
        
        >>> obs = np.array([[16, 18, 16, 14, 12, 12], [32, 24, 16, 28, 20, 24]]).T
        >>> obs.shape
        (6, 2)
        >>> power_divergence(obs, lambda_="log-likelihood")
        (array([ 2.00657316,  6.77634498]), array([ 0.84823477,  0.23781225]))
        
        By setting ``axis=None``, the test is applied to all data in the array,
        which is equivalent to applying the test to the flattened array.
        
        >>> power_divergence(obs, axis=None)
        (23.31034482758621, 0.015975692534127565)
        >>> power_divergence(obs.ravel())
        (23.31034482758621, 0.015975692534127565)
        
        `ddof` is the change to make to the default degrees of freedom.
        
        >>> power_divergence([16, 18, 16, 14, 12, 12], ddof=1)
        (2.0, 0.73575888234288467)
        
        The calculation of the p-values is done by broadcasting the
        test statistic with `ddof`.
        
        >>> power_divergence([16, 18, 16, 14, 12, 12], ddof=[0,1,2])
        (2.0, array([ 0.84914504,  0.73575888,  0.5724067 ]))
        
        `f_obs` and `f_exp` are also broadcast.  In the following, `f_obs` has
        shape (6,) and `f_exp` has shape (2, 6), so the result of broadcasting
        `f_obs` and `f_exp` has shape (2, 6).  To compute the desired chi-squared
        statistics, we must use ``axis=1``:
        
        >>> power_divergence([16, 18, 16, 14, 12, 12],
        ...                  f_exp=[[16, 16, 16, 16, 16, 8],
        ...                         [8, 20, 20, 16, 12, 12]],
        ...                  axis=1)
        (array([ 3.5 ,  9.25]), array([ 0.62338763,  0.09949846]))
    
    ppppcccc__mmaaxx(x, brack=(0.0, 1.0), dist='tukeylambda')
        Calculate the shape parameter that maximizes the PPCC
        
        The probability plot correlation coefficient (PPCC) plot can be used to
        determine the optimal shape parameter for a one-parameter family of
        distributions.  ppcc_max returns the shape parameter that would maximize the
        probability plot correlation coefficient for the given data to a
        one-parameter family of distributions.
        
        Parameters
        ----------
        x : array_like
            Input array.
        brack : tuple, optional
            Triple (a,b,c) where (a<b<c). If bracket consists of two numbers (a, c)
            then they are assumed to be a starting interval for a downhill bracket
            search (see `scipy.optimize.brent`).
        dist : str or stats.distributions instance, optional
            Distribution or distribution function name.  Objects that look enough
            like a stats.distributions instance (i.e. they have a ``ppf`` method)
            are also accepted.  The default is ``'tukeylambda'``.
        
        Returns
        -------
        shape_value : float
            The shape parameter at which the probability plot correlation
            coefficient reaches its max value.
        
        See also
        --------
        ppcc_plot, probplot, boxcox
        
        Notes
        -----
        The brack keyword serves as a starting point which is useful in corner
        cases. One can use a plot to obtain a rough visual estimate of the location
        for the maximum to start the search near it.
        
        References
        ----------
        .. [1] J.J. Filliben, "The Probability Plot Correlation Coefficient Test for
               Normality", Technometrics, Vol. 17, pp. 111-117, 1975.
        
        .. [2] http://www.itl.nist.gov/div898/handbook/eda/section3/ppccplot.htm
        
        Examples
        --------
        First we generate some random data from a Tukey-Lambda distribution,
        with shape parameter -0.7:
        
        >>> from scipy import stats
        >>> x = stats.tukeylambda.rvs(-0.7, loc=2, scale=0.5, size=10000,
        ...                           random_state=1234567) + 1e4
        
        Now we explore this data with a PPCC plot as well as the related
        probability plot and Box-Cox normplot.  A red line is drawn where we
        expect the PPCC value to be maximal (at the shape parameter -0.7 used
        above):
        
        >>> import matplotlib.pyplot as plt
        >>> fig = plt.figure(figsize=(8, 6))
        >>> ax = fig.add_subplot(111)
        >>> res = stats.ppcc_plot(x, -5, 5, plot=ax)
        
        We calculate the value where the shape should reach its maximum and a red
        line is drawn there. The line should coincide with the highest point in the
        ppcc_plot.
        
        >>> max = stats.ppcc_max(x)
        >>> ax.vlines(max, 0, 1, colors='r', label='Expected shape value')
        
        >>> plt.show()
    
    ppppcccc__pplloott(x, a, b, dist='tukeylambda', plot=None, N=80)
        Calculate and optionally plot probability plot correlation coefficient.
        
        The probability plot correlation coefficient (PPCC) plot can be used to
        determine the optimal shape parameter for a one-parameter family of
        distributions.  It cannot be used for distributions without shape parameters
        (like the normal distribution) or with multiple shape parameters.
        
        By default a Tukey-Lambda distribution (`stats.tukeylambda`) is used. A
        Tukey-Lambda PPCC plot interpolates from long-tailed to short-tailed
        distributions via an approximately normal one, and is therefore particularly
        useful in practice.
        
        Parameters
        ----------
        x : array_like
            Input array.
        a, b: scalar
            Lower and upper bounds of the shape parameter to use.
        dist : str or stats.distributions instance, optional
            Distribution or distribution function name.  Objects that look enough
            like a stats.distributions instance (i.e. they have a ``ppf`` method)
            are also accepted.  The default is ``'tukeylambda'``.
        plot : object, optional
            If given, plots PPCC against the shape parameter.
            `plot` is an object that has to have methods "plot" and "text".
            The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
            or a custom object with the same methods.
            Default is None, which means that no plot is created.
        N : int, optional
            Number of points on the horizontal axis (equally distributed from
            `a` to `b`).
        
        Returns
        -------
        svals : ndarray
            The shape values for which `ppcc` was calculated.
        ppcc : ndarray
            The calculated probability plot correlation coefficient values.
        
        See also
        --------
        ppcc_max, probplot, boxcox_normplot, tukeylambda
        
        References
        ----------
        J.J. Filliben, "The Probability Plot Correlation Coefficient Test for
        Normality", Technometrics, Vol. 17, pp. 111-117, 1975.
        
        Examples
        --------
        First we generate some random data from a Tukey-Lambda distribution,
        with shape parameter -0.7:
        
        >>> from scipy import stats
        >>> import matplotlib.pyplot as plt
        >>> np.random.seed(1234567)
        >>> x = stats.tukeylambda.rvs(-0.7, loc=2, scale=0.5, size=10000) + 1e4
        
        Now we explore this data with a PPCC plot as well as the related
        probability plot and Box-Cox normplot.  A red line is drawn where we
        expect the PPCC value to be maximal (at the shape parameter -0.7 used
        above):
        
        >>> fig = plt.figure(figsize=(12, 4))
        >>> ax1 = fig.add_subplot(131)
        >>> ax2 = fig.add_subplot(132)
        >>> ax3 = fig.add_subplot(133)
        >>> res = stats.probplot(x, plot=ax1)
        >>> res = stats.boxcox_normplot(x, -5, 5, plot=ax2)
        >>> res = stats.ppcc_plot(x, -5, 5, plot=ax3)
        >>> ax3.vlines(-0.7, 0, 1, colors='r', label='Expected shape value')
        >>> plt.show()
    
    pprroobbpplloott(x, sparams=(), dist='norm', fit=True, plot=None, rvalue=False)
        Calculate quantiles for a probability plot, and optionally show the plot.
        
        Generates a probability plot of sample data against the quantiles of a
        specified theoretical distribution (the normal distribution by default).
        `probplot` optionally calculates a best-fit line for the data and plots the
        results using Matplotlib or a given plot function.
        
        Parameters
        ----------
        x : array_like
            Sample/response data from which `probplot` creates the plot.
        sparams : tuple, optional
            Distribution-specific shape parameters (shape parameters plus location
            and scale).
        dist : str or stats.distributions instance, optional
            Distribution or distribution function name. The default is 'norm' for a
            normal probability plot.  Objects that look enough like a
            stats.distributions instance (i.e. they have a ``ppf`` method) are also
            accepted.
        fit : bool, optional
            Fit a least-squares regression (best-fit) line to the sample data if
            True (default).
        plot : object, optional
            If given, plots the quantiles and least squares fit.
            `plot` is an object that has to have methods "plot" and "text".
            The `matplotlib.pyplot` module or a Matplotlib Axes object can be used,
            or a custom object with the same methods.
            Default is None, which means that no plot is created.
        
        Returns
        -------
        (osm, osr) : tuple of ndarrays
            Tuple of theoretical quantiles (osm, or order statistic medians) and
            ordered responses (osr).  `osr` is simply sorted input `x`.
            For details on how `osm` is calculated see the Notes section.
        (slope, intercept, r) : tuple of floats, optional
            Tuple  containing the result of the least-squares fit, if that is
            performed by `probplot`. `r` is the square root of the coefficient of
            determination.  If ``fit=False`` and ``plot=None``, this tuple is not
            returned.
        
        Notes
        -----
        Even if `plot` is given, the figure is not shown or saved by `probplot`;
        ``plt.show()`` or ``plt.savefig('figname.png')`` should be used after
        calling `probplot`.
        
        `probplot` generates a probability plot, which should not be confused with
        a Q-Q or a P-P plot.  Statsmodels has more extensive functionality of this
        type, see ``statsmodels.api.ProbPlot``.
        
        The formula used for the theoretical quantiles (horizontal axis of the
        probability plot) is Filliben's estimate::
        
            quantiles = dist.ppf(val), for
        
                    0.5**(1/n),                  for i = n
              val = (i - 0.3175) / (n + 0.365),  for i = 2, ..., n-1
                    1 - 0.5**(1/n),              for i = 1
        
        where ``i`` indicates the i-th ordered value and ``n`` is the total number
        of values.
        
        Examples
        --------
        >>> from scipy import stats
        >>> import matplotlib.pyplot as plt
        >>> nsample = 100
        >>> np.random.seed(7654321)
        
        A t distribution with small degrees of freedom:
        
        >>> ax1 = plt.subplot(221)
        >>> x = stats.t.rvs(3, size=nsample)
        >>> res = stats.probplot(x, plot=plt)
        
        A t distribution with larger degrees of freedom:
        
        >>> ax2 = plt.subplot(222)
        >>> x = stats.t.rvs(25, size=nsample)
        >>> res = stats.probplot(x, plot=plt)
        
        A mixture of two normal distributions with broadcasting:
        
        >>> ax3 = plt.subplot(223)
        >>> x = stats.norm.rvs(loc=[0,5], scale=[1,1.5],
        ...                    size=(nsample//2,2)).ravel()
        >>> res = stats.probplot(x, plot=plt)
        
        A standard normal distribution:
        
        >>> ax4 = plt.subplot(224)
        >>> x = stats.norm.rvs(loc=0, scale=1, size=nsample)
        >>> res = stats.probplot(x, plot=plt)
        
        Produce a new figure with a loggamma distribution, using the ``dist`` and
        ``sparams`` keywords:
        
        >>> fig = plt.figure()
        >>> ax = fig.add_subplot(111)
        >>> x = stats.loggamma.rvs(c=2.5, size=500)
        >>> res = stats.probplot(x, dist=stats.loggamma, sparams=(2.5,), plot=ax)
        >>> ax.set_title("Probplot for loggamma dist with shape parameter 2.5")
        
        Show the results with Matplotlib:
        
        >>> plt.show()
    
    rraannkkddaattaa(a, method='average')
        Assign ranks to data, dealing with ties appropriately.
        
        Ranks begin at 1.  The `method` argument controls how ranks are assigned
        to equal values.  See [1]_ for further discussion of ranking methods.
        
        Parameters
        ----------
        a : array_like
            The array of values to be ranked.  The array is first flattened.
        method : str, optional
            The method used to assign ranks to tied elements.
            The options are 'average', 'min', 'max', 'dense' and 'ordinal'.
        
            'average':
                The average of the ranks that would have been assigned to
                all the tied values is assigned to each value.
            'min':
                The minimum of the ranks that would have been assigned to all
                the tied values is assigned to each value.  (This is also
                referred to as "competition" ranking.)
            'max':
                The maximum of the ranks that would have been assigned to all
                the tied values is assigned to each value.
            'dense':
                Like 'min', but the rank of the next highest element is assigned
                the rank immediately after those assigned to the tied elements.
            'ordinal':
                All values are given a distinct rank, corresponding to the order
                that the values occur in `a`.
        
            The default is 'average'.
        
        Returns
        -------
        ranks : ndarray
             An array of length equal to the size of `a`, containing rank
             scores.
        
        References
        ----------
        .. [1] "Ranking", http://en.wikipedia.org/wiki/Ranking
        
        Examples
        --------
        >>> from scipy.stats import rankdata
        >>> rankdata([0, 2, 3, 2])
        array([ 1. ,  2.5,  4. ,  2.5])
        >>> rankdata([0, 2, 3, 2], method='min')
        array([ 1,  2,  4,  2])
        >>> rankdata([0, 2, 3, 2], method='max')
        array([ 1,  3,  4,  3])
        >>> rankdata([0, 2, 3, 2], method='dense')
        array([ 1,  2,  3,  2])
        >>> rankdata([0, 2, 3, 2], method='ordinal')
        array([ 1,  2,  4,  3])
    
    rraannkkssuummss(x, y)
        Compute the Wilcoxon rank-sum statistic for two samples.
        
        The Wilcoxon rank-sum test tests the null hypothesis that two sets
        of measurements are drawn from the same distribution.  The alternative
        hypothesis is that values in one sample are more likely to be
        larger than the values in the other sample.
        
        This test should be used to compare two samples from continuous
        distributions.  It does not handle ties between measurements
        in x and y.  For tie-handling and an optional continuity correction
        see `scipy.stats.mannwhitneyu`.
        
        Parameters
        ----------
        x,y : array_like
            The data from the two samples
        
        Returns
        -------
        statistic : float
            The test statistic under the large-sample approximation that the
            rank sum statistic is normally distributed
        pvalue : float
            The two-sided p-value of the test
        
        References
        ----------
        .. [1] http://en.wikipedia.org/wiki/Wilcoxon_rank-sum_test
    
    rreellffrreeqq(a, numbins=10, defaultreallimits=None, weights=None)
        Return a relative frequency histogram, using the histogram function.
        
        A relative frequency  histogram is a mapping of the number of
        observations in each of the bins relative to the total of observations.
        
        Parameters
        ----------
        a : array_like
            Input array.
        numbins : int, optional
            The number of bins to use for the histogram. Default is 10.
        defaultreallimits : tuple (lower, upper), optional
            The lower and upper values for the range of the histogram.
            If no value is given, a range slightly larger than the range of the
            values in a is used. Specifically ``(a.min() - s, a.max() + s)``,
            where ``s = (1/2)(a.max() - a.min()) / (numbins - 1)``.
        weights : array_like, optional
            The weights for each value in `a`. Default is None, which gives each
            value a weight of 1.0
        
        Returns
        -------
        frequency : ndarray
            Binned values of relative frequency.
        lowerlimit : float
            Lower real limit
        binsize : float
            Width of each bin.
        extrapoints : int
            Extra points.
        
        Examples
        --------
        >>> import matplotlib.pyplot as plt
        >>> from scipy import stats
        >>> a = np.array([2, 4, 1, 2, 3, 2])
        >>> res = stats.relfreq(a, numbins=4)
        >>> res.frequency
        array([ 0.16666667, 0.5       , 0.16666667,  0.16666667])
        >>> np.sum(res.frequency)  # relative frequencies should add up to 1
        1.0
        
        Create a normal distribution with 1000 random values
        
        >>> rng = np.random.RandomState(seed=12345)
        >>> samples = stats.norm.rvs(size=1000, random_state=rng)
        
        Calculate relative frequencies
        
        >>> res = stats.relfreq(samples, numbins=25)
        
        Calculate space of values for x
        
        >>> x = res.lowerlimit + np.linspace(0, res.binsize*res.frequency.size,
        ...                                  res.frequency.size)
        
        Plot relative frequency histogram
        
        >>> fig = plt.figure(figsize=(5, 4))
        >>> ax = fig.add_subplot(1, 1, 1)
        >>> ax.bar(x, res.frequency, width=res.binsize)
        >>> ax.set_title('Relative frequency histogram')
        >>> ax.set_xlim([x.min(), x.max()])
        
        >>> plt.show()
    
    ssccoorreeaattppeerrcceennttiillee(a, per, limit=(), interpolation_method='fraction', axis=None)
        Calculate the score at a given percentile of the input sequence.
        
        For example, the score at `per=50` is the median. If the desired quantile
        lies between two data points, we interpolate between them, according to
        the value of `interpolation`. If the parameter `limit` is provided, it
        should be a tuple (lower, upper) of two values.
        
        Parameters
        ----------
        a : array_like
            A 1-D array of values from which to extract score.
        per : array_like
            Percentile(s) at which to extract score.  Values should be in range
            [0,100].
        limit : tuple, optional
            Tuple of two scalars, the lower and upper limits within which to
            compute the percentile. Values of `a` outside
            this (closed) interval will be ignored.
        interpolation_method : {'fraction', 'lower', 'higher'}, optional
            This optional parameter specifies the interpolation method to use,
            when the desired quantile lies between two data points `i` and `j`
        
              - fraction: ``i + (j - i) * fraction`` where ``fraction`` is the
                fractional part of the index surrounded by ``i`` and ``j``.
              - lower: ``i``.
              - higher: ``j``.
        
        axis : int, optional
            Axis along which the percentiles are computed. Default is None. If
            None, compute over the whole array `a`.
        
        Returns
        -------
        score : float or ndarray
            Score at percentile(s).
        
        See Also
        --------
        percentileofscore, numpy.percentile
        
        Notes
        -----
        This function will become obsolete in the future.
        For Numpy 1.9 and higher, `numpy.percentile` provides all the functionality
        that `scoreatpercentile` provides.  And it's significantly faster.
        Therefore it's recommended to use `numpy.percentile` for users that have
        numpy >= 1.9.
        
        Examples
        --------
        >>> from scipy import stats
        >>> a = np.arange(100)
        >>> stats.scoreatpercentile(a, 50)
        49.5
    
    sseemm(a, axis=0, ddof=1, nan_policy='propagate')
        Calculate the standard error of the mean (or standard error of
        measurement) of the values in the input array.
        
        Parameters
        ----------
        a : array_like
            An array containing the values for which the standard error is
            returned.
        axis : int or None, optional
            Axis along which to operate. Default is 0. If None, compute over
            the whole array `a`.
        ddof : int, optional
            Delta degrees-of-freedom. How many degrees of freedom to adjust
            for bias in limited samples relative to the population estimate
            of variance. Defaults to 1.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        s : ndarray or float
            The standard error of the mean in the sample(s), along the input axis.
        
        Notes
        -----
        The default value for `ddof` is different to the default (0) used by other
        ddof containing routines, such as np.std and np.nanstd.
        
        Examples
        --------
        Find standard error along the first axis:
        
        >>> from scipy import stats
        >>> a = np.arange(20).reshape(5,4)
        >>> stats.sem(a)
        array([ 2.8284,  2.8284,  2.8284,  2.8284])
        
        Find standard error across the whole array, using n degrees of freedom:
        
        >>> stats.sem(a, axis=None, ddof=0)
        1.2893796958227628
    
    sshhaappiirroo(x)
        Perform the Shapiro-Wilk test for normality.
        
        The Shapiro-Wilk test tests the null hypothesis that the
        data was drawn from a normal distribution.
        
        Parameters
        ----------
        x : array_like
            Array of sample data.
        
        Returns
        -------
        W : float
            The test statistic.
        p-value : float
            The p-value for the hypothesis test.
        
        See Also
        --------
        anderson : The Anderson-Darling test for normality
        kstest : The Kolmogorov-Smirnov test for goodness of fit.
        
        Notes
        -----
        The algorithm used is described in [4]_ but censoring parameters as
        described are not implemented. For N > 5000 the W test statistic is accurate
        but the p-value may not be.
        
        The chance of rejecting the null hypothesis when it is true is close to 5%
        regardless of sample size.
        
        References
        ----------
        .. [1] http://www.itl.nist.gov/div898/handbook/prc/section2/prc213.htm
        .. [2] Shapiro, S. S. & Wilk, M.B (1965). An analysis of variance test for
               normality (complete samples), Biometrika, Vol. 52, pp. 591-611.
        .. [3] Razali, N. M. & Wah, Y. B. (2011) Power comparisons of Shapiro-Wilk,
               Kolmogorov-Smirnov, Lilliefors and Anderson-Darling tests, Journal of
               Statistical Modeling and Analytics, Vol. 2, pp. 21-33.
        .. [4] ALGORITHM AS R94 APPL. STATIST. (1995) VOL. 44, NO. 4.
        
        Examples
        --------
        >>> from scipy import stats
        >>> np.random.seed(12345678)
        >>> x = stats.norm.rvs(loc=5, scale=3, size=100)
        >>> stats.shapiro(x)
        (0.9772805571556091, 0.08144091814756393)
    
    ssiiggmmaacclliipp(a, low=4.0, high=4.0)
        Iterative sigma-clipping of array elements.
        
        Starting from the full sample, all elements outside the critical range are
        removed, i.e. all elements of the input array `c` that satisfy either of
        the following conditions ::
        
            c < mean(c) - std(c)*low
            c > mean(c) + std(c)*high
        
        The iteration continues with the updated sample until no
        elements are outside the (updated) range.
        
        Parameters
        ----------
        a : array_like
            Data array, will be raveled if not 1-D.
        low : float, optional
            Lower bound factor of sigma clipping. Default is 4.
        high : float, optional
            Upper bound factor of sigma clipping. Default is 4.
        
        Returns
        -------
        clipped : ndarray
            Input array with clipped elements removed.
        lower : float
            Lower threshold value use for clipping.
        upper : float
            Upper threshold value use for clipping.
        
        Examples
        --------
        >>> from scipy.stats import sigmaclip
        >>> a = np.concatenate((np.linspace(9.5, 10.5, 31),
        ...                     np.linspace(0, 20, 5)))
        >>> fact = 1.5
        >>> c, low, upp = sigmaclip(a, fact, fact)
        >>> c
        array([  9.96666667,  10.        ,  10.03333333,  10.        ])
        >>> c.var(), c.std()
        (0.00055555555555555165, 0.023570226039551501)
        >>> low, c.mean() - fact*c.std(), c.min()
        (9.9646446609406727, 9.9646446609406727, 9.9666666666666668)
        >>> upp, c.mean() + fact*c.std(), c.max()
        (10.035355339059327, 10.035355339059327, 10.033333333333333)
        
        >>> a = np.concatenate((np.linspace(9.5, 10.5, 11),
        ...                     np.linspace(-100, -50, 3)))
        >>> c, low, upp = sigmaclip(a, 1.8, 1.8)
        >>> (c == np.linspace(9.5, 10.5, 11)).all()
        True
    
    sskkeeww(a, axis=0, bias=True, nan_policy='propagate')
        Compute the skewness of a data set.
        
        For normally distributed data, the skewness should be about 0. For
        unimodal continuous distributions, a skewness value > 0 means that
        there is more weight in the right tail of the distribution. The
        function `skewtest` can be used to determine if the skewness value
        is close enough to 0, statistically speaking.
        
        Parameters
        ----------
        a : ndarray
            data
        axis : int or None, optional
            Axis along which skewness is calculated. Default is 0.
            If None, compute over the whole array `a`.
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        skewness : ndarray
            The skewness of values along an axis, returning 0 where all values are
            equal.
        
        References
        ----------
        
        .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
           Probability and Statistics Tables and Formulae. Chapman & Hall: New
           York. 2000.
           Section 2.2.24.1
        
        Examples
        --------
        >>> from scipy.stats import skew
        >>> skew([1, 2, 3, 4, 5])
        0.0
        >>> skew([2, 8, 0, 4, 1, 9, 9, 0])
        0.2650554122698573
    
    sskkeewwtteesstt(a, axis=0, nan_policy='propagate')
        Test whether the skew is different from the normal distribution.
        
        This function tests the null hypothesis that the skewness of
        the population that the sample was drawn from is the same
        as that of a corresponding normal distribution.
        
        Parameters
        ----------
        a : array
            The data to be tested
        axis : int or None, optional
           Axis along which statistics are calculated. Default is 0.
           If None, compute over the whole array `a`.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        statistic : float
            The computed z-score for this test.
        pvalue : float
            a 2-sided p-value for the hypothesis test
        
        Notes
        -----
        The sample size must be at least 8.
        
        References
        ----------
        .. [1] R. B. D'Agostino, A. J. Belanger and R. B. D'Agostino Jr.,
                "A suggestion for using powerful and informative tests of
                normality", American Statistician 44, pp. 316-321, 1990.
        
        Examples
        --------
        >>> from scipy.stats import skewtest
        >>> skewtest([1, 2, 3, 4, 5, 6, 7, 8])
        SkewtestResult(statistic=1.0108048609177787, pvalue=0.3121098361421897)
        >>> skewtest([2, 8, 0, 4, 1, 9, 9, 0])
        SkewtestResult(statistic=0.44626385374196975, pvalue=0.6554066631275459)
        >>> skewtest([1, 2, 3, 4, 5, 6, 7, 8000])
        SkewtestResult(statistic=3.571773510360407, pvalue=0.0003545719905823133)
        >>> skewtest([100, 100, 100, 100, 100, 100, 100, 101])
        SkewtestResult(statistic=3.5717766638478072, pvalue=0.000354567720281634)
    
    ssppeeaarrmmaannrr(a, b=None, axis=0, nan_policy='propagate')
        Calculate a Spearman rank-order correlation coefficient and the p-value
        to test for non-correlation.
        
        The Spearman correlation is a nonparametric measure of the monotonicity
        of the relationship between two datasets. Unlike the Pearson correlation,
        the Spearman correlation does not assume that both datasets are normally
        distributed. Like other correlation coefficients, this one varies
        between -1 and +1 with 0 implying no correlation. Correlations of -1 or
        +1 imply an exact monotonic relationship. Positive correlations imply that
        as x increases, so does y. Negative correlations imply that as x
        increases, y decreases.
        
        The p-value roughly indicates the probability of an uncorrelated system
        producing datasets that have a Spearman correlation at least as extreme
        as the one computed from these datasets. The p-values are not entirely
        reliable but are probably reasonable for datasets larger than 500 or so.
        
        Parameters
        ----------
        a, b : 1D or 2D array_like, b is optional
            One or two 1-D or 2-D arrays containing multiple variables and
            observations. When these are 1-D, each represents a vector of
            observations of a single variable. For the behavior in the 2-D case,
            see under ``axis``, below.
            Both arrays need to have the same length in the ``axis`` dimension.
        axis : int or None, optional
            If axis=0 (default), then each column represents a variable, with
            observations in the rows. If axis=1, the relationship is transposed:
            each row represents a variable, while the columns contain observations.
            If axis=None, then both arrays will be raveled.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        correlation : float or ndarray (2-D square)
            Spearman correlation matrix or correlation coefficient (if only 2
            variables are given as parameters. Correlation matrix is square with
            length equal to total number of variables (columns or rows) in a and b
            combined.
        pvalue : float
            The two-sided p-value for a hypothesis test whose null hypothesis is
            that two sets of data are uncorrelated, has same dimension as rho.
        
        Notes
        -----
        Changes in scipy 0.8.0: rewrite to add tie-handling, and axis.
        
        References
        ----------
        
        .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
           Probability and Statistics Tables and Formulae. Chapman & Hall: New
           York. 2000.
           Section  14.7
        
        Examples
        --------
        >>> from scipy import stats
        >>> stats.spearmanr([1,2,3,4,5], [5,6,7,8,7])
        (0.82078268166812329, 0.088587005313543798)
        >>> np.random.seed(1234321)
        >>> x2n = np.random.randn(100, 2)
        >>> y2n = np.random.randn(100, 2)
        >>> stats.spearmanr(x2n)
        (0.059969996999699973, 0.55338590803773591)
        >>> stats.spearmanr(x2n[:,0], x2n[:,1])
        (0.059969996999699973, 0.55338590803773591)
        >>> rho, pval = stats.spearmanr(x2n, y2n)
        >>> rho
        array([[ 1.        ,  0.05997   ,  0.18569457,  0.06258626],
               [ 0.05997   ,  1.        ,  0.110003  ,  0.02534653],
               [ 0.18569457,  0.110003  ,  1.        ,  0.03488749],
               [ 0.06258626,  0.02534653,  0.03488749,  1.        ]])
        >>> pval
        array([[ 0.        ,  0.55338591,  0.06435364,  0.53617935],
               [ 0.55338591,  0.        ,  0.27592895,  0.80234077],
               [ 0.06435364,  0.27592895,  0.        ,  0.73039992],
               [ 0.53617935,  0.80234077,  0.73039992,  0.        ]])
        >>> rho, pval = stats.spearmanr(x2n.T, y2n.T, axis=1)
        >>> rho
        array([[ 1.        ,  0.05997   ,  0.18569457,  0.06258626],
               [ 0.05997   ,  1.        ,  0.110003  ,  0.02534653],
               [ 0.18569457,  0.110003  ,  1.        ,  0.03488749],
               [ 0.06258626,  0.02534653,  0.03488749,  1.        ]])
        >>> stats.spearmanr(x2n, y2n, axis=None)
        (0.10816770419260482, 0.1273562188027364)
        >>> stats.spearmanr(x2n.ravel(), y2n.ravel())
        (0.10816770419260482, 0.1273562188027364)
        
        >>> xint = np.random.randint(10, size=(100, 2))
        >>> stats.spearmanr(xint)
        (0.052760927029710199, 0.60213045837062351)
    
    tthheeiillssllooppeess(y, x=None, alpha=0.95)
        Computes the Theil-Sen estimator for a set of points (x, y).
        
        `theilslopes` implements a method for robust linear regression.  It
        computes the slope as the median of all slopes between paired values.
        
        Parameters
        ----------
        y : array_like
            Dependent variable.
        x : array_like or None, optional
            Independent variable. If None, use ``arange(len(y))`` instead.
        alpha : float, optional
            Confidence degree between 0 and 1. Default is 95% confidence.
            Note that `alpha` is symmetric around 0.5, i.e. both 0.1 and 0.9 are
            interpreted as "find the 90% confidence interval".
        
        Returns
        -------
        medslope : float
            Theil slope.
        medintercept : float
            Intercept of the Theil line, as ``median(y) - medslope*median(x)``.
        lo_slope : float
            Lower bound of the confidence interval on `medslope`.
        up_slope : float
            Upper bound of the confidence interval on `medslope`.
        
        Notes
        -----
        The implementation of `theilslopes` follows [1]_. The intercept is
        not defined in [1]_, and here it is defined as ``median(y) -
        medslope*median(x)``, which is given in [3]_. Other definitions of
        the intercept exist in the literature. A confidence interval for
        the intercept is not given as this question is not addressed in
        [1]_.
        
        References
        ----------
        .. [1] P.K. Sen, "Estimates of the regression coefficient based on Kendall's tau",
               J. Am. Stat. Assoc., Vol. 63, pp. 1379-1389, 1968.
        .. [2] H. Theil, "A rank-invariant method of linear and polynomial
               regression analysis I, II and III",  Nederl. Akad. Wetensch., Proc.
               53:, pp. 386-392, pp. 521-525, pp. 1397-1412, 1950.
        .. [3] W.L. Conover, "Practical nonparametric statistics", 2nd ed.,
               John Wiley and Sons, New York, pp. 493.
        
        Examples
        --------
        >>> from scipy import stats
        >>> import matplotlib.pyplot as plt
        
        >>> x = np.linspace(-5, 5, num=150)
        >>> y = x + np.random.normal(size=x.size)
        >>> y[11:15] += 10  # add outliers
        >>> y[-5:] -= 7
        
        Compute the slope, intercept and 90% confidence interval.  For comparison,
        also compute the least-squares fit with `linregress`:
        
        >>> res = stats.theilslopes(y, x, 0.90)
        >>> lsq_res = stats.linregress(x, y)
        
        Plot the results. The Theil-Sen regression line is shown in red, with the
        dashed red lines illustrating the confidence interval of the slope (note
        that the dashed red lines are not the confidence interval of the regression
        as the confidence interval of the intercept is not included). The green
        line shows the least-squares fit for comparison.
        
        >>> fig = plt.figure()
        >>> ax = fig.add_subplot(111)
        >>> ax.plot(x, y, 'b.')
        >>> ax.plot(x, res[1] + res[0] * x, 'r-')
        >>> ax.plot(x, res[1] + res[2] * x, 'r--')
        >>> ax.plot(x, res[1] + res[3] * x, 'r--')
        >>> ax.plot(x, lsq_res[1] + lsq_res[0] * x, 'g-')
        >>> plt.show()
    
    ttiieeccoorrrreecctt(rankvals)
        Tie correction factor for ties in the Mann-Whitney U and
        Kruskal-Wallis H tests.
        
        Parameters
        ----------
        rankvals : array_like
            A 1-D sequence of ranks.  Typically this will be the array
            returned by `stats.rankdata`.
        
        Returns
        -------
        factor : float
            Correction factor for U or H.
        
        See Also
        --------
        rankdata : Assign ranks to the data
        mannwhitneyu : Mann-Whitney rank test
        kruskal : Kruskal-Wallis H test
        
        References
        ----------
        .. [1] Siegel, S. (1956) Nonparametric Statistics for the Behavioral
               Sciences.  New York: McGraw-Hill.
        
        Examples
        --------
        >>> from scipy.stats import tiecorrect, rankdata
        >>> tiecorrect([1, 2.5, 2.5, 4])
        0.9
        >>> ranks = rankdata([1, 3, 2, 4, 5, 7, 2, 8, 4])
        >>> ranks
        array([ 1. ,  4. ,  2.5,  5.5,  7. ,  8. ,  2.5,  9. ,  5.5])
        >>> tiecorrect(ranks)
        0.9833333333333333
    
    ttmmaaxx(a, upperlimit=None, axis=0, inclusive=True, nan_policy='propagate')
        Compute the trimmed maximum.
        
        This function computes the maximum value of an array along a given axis,
        while ignoring values larger than a specified upper limit.
        
        Parameters
        ----------
        a : array_like
            array of values
        upperlimit : None or float, optional
            Values in the input array greater than the given limit will be ignored.
            When upperlimit is None, then all values are used. The default value
            is None.
        axis : int or None, optional
            Axis along which to operate. Default is 0. If None, compute over the
            whole array `a`.
        inclusive : {True, False}, optional
            This flag determines whether values exactly equal to the upper limit
            are included.  The default value is True.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        tmax : float, int or ndarray
        
        Examples
        --------
        >>> from scipy import stats
        >>> x = np.arange(20)
        >>> stats.tmax(x)
        19
        
        >>> stats.tmax(x, 13)
        13
        
        >>> stats.tmax(x, 13, inclusive=False)
        12
    
    ttmmeeaann(a, limits=None, inclusive=(True, True), axis=None)
        Compute the trimmed mean.
        
        This function finds the arithmetic mean of given values, ignoring values
        outside the given `limits`.
        
        Parameters
        ----------
        a : array_like
            Array of values.
        limits : None or (lower limit, upper limit), optional
            Values in the input array less than the lower limit or greater than the
            upper limit will be ignored.  When limits is None (default), then all
            values are used.  Either of the limit values in the tuple can also be
            None representing a half-open interval.
        inclusive : (bool, bool), optional
            A tuple consisting of the (lower flag, upper flag).  These flags
            determine whether values exactly equal to the lower or upper limits
            are included.  The default value is (True, True).
        axis : int or None, optional
            Axis along which to compute test. Default is None.
        
        Returns
        -------
        tmean : float
        
        See also
        --------
        trim_mean : returns mean after trimming a proportion from both tails.
        
        Examples
        --------
        >>> from scipy import stats
        >>> x = np.arange(20)
        >>> stats.tmean(x)
        9.5
        >>> stats.tmean(x, (3,17))
        10.0
    
    ttmmiinn(a, lowerlimit=None, axis=0, inclusive=True, nan_policy='propagate')
        Compute the trimmed minimum.
        
        This function finds the miminum value of an array `a` along the
        specified axis, but only considering values greater than a specified
        lower limit.
        
        Parameters
        ----------
        a : array_like
            array of values
        lowerlimit : None or float, optional
            Values in the input array less than the given limit will be ignored.
            When lowerlimit is None, then all values are used. The default value
            is None.
        axis : int or None, optional
            Axis along which to operate. Default is 0. If None, compute over the
            whole array `a`.
        inclusive : {True, False}, optional
            This flag determines whether values exactly equal to the lower limit
            are included.  The default value is True.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        tmin : float, int or ndarray
        
        Examples
        --------
        >>> from scipy import stats
        >>> x = np.arange(20)
        >>> stats.tmin(x)
        0
        
        >>> stats.tmin(x, 13)
        13
        
        >>> stats.tmin(x, 13, inclusive=False)
        14
    
    ttrriimm11(a, proportiontocut, tail='right', axis=0)
        Slices off a proportion from ONE end of the passed array distribution.
        
        If `proportiontocut` = 0.1, slices off 'leftmost' or 'rightmost'
        10% of scores. The lowest or highest values are trimmed (depending on
        the tail).
        Slices off less if proportion results in a non-integer slice index
        (i.e., conservatively slices off `proportiontocut` ).
        
        Parameters
        ----------
        a : array_like
            Input array
        proportiontocut : float
            Fraction to cut off of 'left' or 'right' of distribution
        tail : {'left', 'right'}, optional
            Defaults to 'right'.
        axis : int or None, optional
            Axis along which to trim data. Default is 0. If None, compute over
            the whole array `a`.
        
        Returns
        -------
        trim1 : ndarray
            Trimmed version of array `a`. The order of the trimmed content is
            undefined.
    
    ttrriimm__mmeeaann(a, proportiontocut, axis=0)
        Return mean of array after trimming distribution from both tails.
        
        If `proportiontocut` = 0.1, slices off 'leftmost' and 'rightmost' 10% of
        scores. The input is sorted before slicing. Slices off less if proportion
        results in a non-integer slice index (i.e., conservatively slices off
        `proportiontocut` ).
        
        Parameters
        ----------
        a : array_like
            Input array
        proportiontocut : float
            Fraction to cut off of both tails of the distribution
        axis : int or None, optional
            Axis along which the trimmed means are computed. Default is 0.
            If None, compute over the whole array `a`.
        
        Returns
        -------
        trim_mean : ndarray
            Mean of trimmed array.
        
        See Also
        --------
        trimboth
        tmean : compute the trimmed mean ignoring values outside given `limits`.
        
        Examples
        --------
        >>> from scipy import stats
        >>> x = np.arange(20)
        >>> stats.trim_mean(x, 0.1)
        9.5
        >>> x2 = x.reshape(5, 4)
        >>> x2
        array([[ 0,  1,  2,  3],
               [ 4,  5,  6,  7],
               [ 8,  9, 10, 11],
               [12, 13, 14, 15],
               [16, 17, 18, 19]])
        >>> stats.trim_mean(x2, 0.25)
        array([  8.,   9.,  10.,  11.])
        >>> stats.trim_mean(x2, 0.25, axis=1)
        array([  1.5,   5.5,   9.5,  13.5,  17.5])
    
    ttrriimmbbootthh(a, proportiontocut, axis=0)
        Slices off a proportion of items from both ends of an array.
        
        Slices off the passed proportion of items from both ends of the passed
        array (i.e., with `proportiontocut` = 0.1, slices leftmost 10% **and**
        rightmost 10% of scores). The trimmed values are the lowest and
        highest ones.
        Slices off less if proportion results in a non-integer slice index (i.e.,
        conservatively slices off`proportiontocut`).
        
        Parameters
        ----------
        a : array_like
            Data to trim.
        proportiontocut : float
            Proportion (in range 0-1) of total data set to trim of each end.
        axis : int or None, optional
            Axis along which to trim data. Default is 0. If None, compute over
            the whole array `a`.
        
        Returns
        -------
        out : ndarray
            Trimmed version of array `a`. The order of the trimmed content
            is undefined.
        
        See Also
        --------
        trim_mean
        
        Examples
        --------
        >>> from scipy import stats
        >>> a = np.arange(20)
        >>> b = stats.trimboth(a, 0.1)
        >>> b.shape
        (16,)
    
    ttsseemm(a, limits=None, inclusive=(True, True), axis=0, ddof=1)
        Compute the trimmed standard error of the mean.
        
        This function finds the standard error of the mean for given
        values, ignoring values outside the given `limits`.
        
        Parameters
        ----------
        a : array_like
            array of values
        limits : None or (lower limit, upper limit), optional
            Values in the input array less than the lower limit or greater than the
            upper limit will be ignored. When limits is None, then all values are
            used. Either of the limit values in the tuple can also be None
            representing a half-open interval.  The default value is None.
        inclusive : (bool, bool), optional
            A tuple consisting of the (lower flag, upper flag).  These flags
            determine whether values exactly equal to the lower or upper limits
            are included.  The default value is (True, True).
        axis : int or None, optional
            Axis along which to operate. Default is 0. If None, compute over the
            whole array `a`.
        ddof : int, optional
            Delta degrees of freedom.  Default is 1.
        
        Returns
        -------
        tsem : float
        
        Notes
        -----
        `tsem` uses unbiased sample standard deviation, i.e. it uses a
        correction factor ``n / (n - 1)``.
        
        Examples
        --------
        >>> from scipy import stats
        >>> x = np.arange(20)
        >>> stats.tsem(x)
        1.3228756555322954
        >>> stats.tsem(x, (3,17))
        1.1547005383792515
    
    ttssttdd(a, limits=None, inclusive=(True, True), axis=0, ddof=1)
        Compute the trimmed sample standard deviation.
        
        This function finds the sample standard deviation of given values,
        ignoring values outside the given `limits`.
        
        Parameters
        ----------
        a : array_like
            array of values
        limits : None or (lower limit, upper limit), optional
            Values in the input array less than the lower limit or greater than the
            upper limit will be ignored. When limits is None, then all values are
            used. Either of the limit values in the tuple can also be None
            representing a half-open interval.  The default value is None.
        inclusive : (bool, bool), optional
            A tuple consisting of the (lower flag, upper flag).  These flags
            determine whether values exactly equal to the lower or upper limits
            are included.  The default value is (True, True).
        axis : int or None, optional
            Axis along which to operate. Default is 0. If None, compute over the
            whole array `a`.
        ddof : int, optional
            Delta degrees of freedom.  Default is 1.
        
        Returns
        -------
        tstd : float
        
        Notes
        -----
        `tstd` computes the unbiased sample standard deviation, i.e. it uses a
        correction factor ``n / (n - 1)``.
        
        Examples
        --------
        >>> from scipy import stats
        >>> x = np.arange(20)
        >>> stats.tstd(x)
        5.9160797830996161
        >>> stats.tstd(x, (3,17))
        4.4721359549995796
    
    tttteesstt__11ssaammpp(a, popmean, axis=0, nan_policy='propagate')
        Calculate the T-test for the mean of ONE group of scores.
        
        This is a two-sided test for the null hypothesis that the expected value
        (mean) of a sample of independent observations `a` is equal to the given
        population mean, `popmean`.
        
        Parameters
        ----------
        a : array_like
            sample observation
        popmean : float or array_like
            expected value in null hypothesis. If array_like, then it must have the
            same shape as `a` excluding the axis dimension
        axis : int or None, optional
            Axis along which to compute test. If None, compute over the whole
            array `a`.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        statistic : float or array
            t-statistic
        pvalue : float or array
            two-tailed p-value
        
        Examples
        --------
        >>> from scipy import stats
        
        >>> np.random.seed(7654567)  # fix seed to get the same result
        >>> rvs = stats.norm.rvs(loc=5, scale=10, size=(50,2))
        
        Test if mean of random sample is equal to true mean, and different mean.
        We reject the null hypothesis in the second case and don't reject it in
        the first case.
        
        >>> stats.ttest_1samp(rvs,5.0)
        (array([-0.68014479, -0.04323899]), array([ 0.49961383,  0.96568674]))
        >>> stats.ttest_1samp(rvs,0.0)
        (array([ 2.77025808,  4.11038784]), array([ 0.00789095,  0.00014999]))
        
        Examples using axis and non-scalar dimension for population mean.
        
        >>> stats.ttest_1samp(rvs,[5.0,0.0])
        (array([-0.68014479,  4.11038784]), array([  4.99613833e-01,   1.49986458e-04]))
        >>> stats.ttest_1samp(rvs.T,[5.0,0.0],axis=1)
        (array([-0.68014479,  4.11038784]), array([  4.99613833e-01,   1.49986458e-04]))
        >>> stats.ttest_1samp(rvs,[[5.0],[0.0]])
        (array([[-0.68014479, -0.04323899],
               [ 2.77025808,  4.11038784]]), array([[  4.99613833e-01,   9.65686743e-01],
               [  7.89094663e-03,   1.49986458e-04]]))
    
    tttteesstt__iinndd(a, b, axis=0, equal_var=True, nan_policy='propagate')
        Calculate the T-test for the means of *two independent* samples of scores.
        
        This is a two-sided test for the null hypothesis that 2 independent samples
        have identical average (expected) values. This test assumes that the
        populations have identical variances by default.
        
        Parameters
        ----------
        a, b : array_like
            The arrays must have the same shape, except in the dimension
            corresponding to `axis` (the first, by default).
        axis : int or None, optional
            Axis along which to compute test. If None, compute over the whole
            arrays, `a`, and `b`.
        equal_var : bool, optional
            If True (default), perform a standard independent 2 sample test
            that assumes equal population variances [1]_.
            If False, perform Welch's t-test, which does not assume equal
            population variance [2]_.
        
            .. versionadded:: 0.11.0
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        
        Returns
        -------
        statistic : float or array
            The calculated t-statistic.
        pvalue : float or array
            The two-tailed p-value.
        
        Notes
        -----
        We can use this test, if we observe two independent samples from
        the same or different population, e.g. exam scores of boys and
        girls or of two ethnic groups. The test measures whether the
        average (expected) value differs significantly across samples. If
        we observe a large p-value, for example larger than 0.05 or 0.1,
        then we cannot reject the null hypothesis of identical average scores.
        If the p-value is smaller than the threshold, e.g. 1%, 5% or 10%,
        then we reject the null hypothesis of equal averages.
        
        References
        ----------
        .. [1] http://en.wikipedia.org/wiki/T-test#Independent_two-sample_t-test
        
        .. [2] http://en.wikipedia.org/wiki/Welch%27s_t_test
        
        Examples
        --------
        >>> from scipy import stats
        >>> np.random.seed(12345678)
        
        Test with sample with identical means:
        
        >>> rvs1 = stats.norm.rvs(loc=5,scale=10,size=500)
        >>> rvs2 = stats.norm.rvs(loc=5,scale=10,size=500)
        >>> stats.ttest_ind(rvs1,rvs2)
        (0.26833823296239279, 0.78849443369564776)
        >>> stats.ttest_ind(rvs1,rvs2, equal_var = False)
        (0.26833823296239279, 0.78849452749500748)
        
        `ttest_ind` underestimates p for unequal variances:
        
        >>> rvs3 = stats.norm.rvs(loc=5, scale=20, size=500)
        >>> stats.ttest_ind(rvs1, rvs3)
        (-0.46580283298287162, 0.64145827413436174)
        >>> stats.ttest_ind(rvs1, rvs3, equal_var = False)
        (-0.46580283298287162, 0.64149646246569292)
        
        When n1 != n2, the equal variance t-statistic is no longer equal to the
        unequal variance t-statistic:
        
        >>> rvs4 = stats.norm.rvs(loc=5, scale=20, size=100)
        >>> stats.ttest_ind(rvs1, rvs4)
        (-0.99882539442782481, 0.3182832709103896)
        >>> stats.ttest_ind(rvs1, rvs4, equal_var = False)
        (-0.69712570584654099, 0.48716927725402048)
        
        T-test with different means, variance, and n:
        
        >>> rvs5 = stats.norm.rvs(loc=8, scale=20, size=100)
        >>> stats.ttest_ind(rvs1, rvs5)
        (-1.4679669854490653, 0.14263895620529152)
        >>> stats.ttest_ind(rvs1, rvs5, equal_var = False)
        (-0.94365973617132992, 0.34744170334794122)
    
    tttteesstt__iinndd__ffrroomm__ssttaattss(mean1, std1, nobs1, mean2, std2, nobs2, equal_var=True)
        T-test for means of two independent samples from descriptive statistics.
        
        This is a two-sided test for the null hypothesis that two independent
        samples have identical average (expected) values.
        
        Parameters
        ----------
        mean1 : array_like
            The mean(s) of sample 1.
        std1 : array_like
            The standard deviation(s) of sample 1.
        nobs1 : array_like
            The number(s) of observations of sample 1.
        mean2 : array_like
            The mean(s) of sample 2
        std2 : array_like
            The standard deviations(s) of sample 2.
        nobs2 : array_like
            The number(s) of observations of sample 2.
        equal_var : bool, optional
            If True (default), perform a standard independent 2 sample test
            that assumes equal population variances [1]_.
            If False, perform Welch's t-test, which does not assume equal
            population variance [2]_.
        
        Returns
        -------
        statistic : float or array
            The calculated t-statistics
        pvalue : float or array
            The two-tailed p-value.
        
        See Also
        --------
        scipy.stats.ttest_ind
        
        Notes
        -----
        
        .. versionadded:: 0.16.0
        
        References
        ----------
        .. [1] http://en.wikipedia.org/wiki/T-test#Independent_two-sample_t-test
        
        .. [2] http://en.wikipedia.org/wiki/Welch%27s_t_test
        
        Examples
        --------
        Suppose we have the summary data for two samples, as follows::
        
                             Sample   Sample
                       Size   Mean   Variance
            Sample 1    13    15.0     87.5
            Sample 2    11    12.0     39.0
        
        Apply the t-test to this data (with the assumption that the population
        variances are equal):
        
        >>> from scipy.stats import ttest_ind_from_stats
        >>> ttest_ind_from_stats(mean1=15.0, std1=np.sqrt(87.5), nobs1=13,
        ...                      mean2=12.0, std2=np.sqrt(39.0), nobs2=11)
        Ttest_indResult(statistic=0.9051358093310269, pvalue=0.3751996797581487)
        
        For comparison, here is the data from which those summary statistics
        were taken.  With this data, we can compute the same result using
        `scipy.stats.ttest_ind`:
        
        >>> a = np.array([1, 3, 4, 6, 11, 13, 15, 19, 22, 24, 25, 26, 26])
        >>> b = np.array([2, 4, 6, 9, 11, 13, 14, 15, 18, 19, 21])
        >>> from scipy.stats import ttest_ind
        >>> ttest_ind(a, b)
        Ttest_indResult(statistic=0.905135809331027, pvalue=0.3751996797581486)
    
    tttteesstt__rreell(a, b, axis=0, nan_policy='propagate')
        Calculate the T-test on TWO RELATED samples of scores, a and b.
        
        This is a two-sided test for the null hypothesis that 2 related or
        repeated samples have identical average (expected) values.
        
        Parameters
        ----------
        a, b : array_like
            The arrays must have the same shape.
        axis : int or None, optional
            Axis along which to compute test. If None, compute over the whole
            arrays, `a`, and `b`.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        statistic : float or array
            t-statistic
        pvalue : float or array
            two-tailed p-value
        
        Notes
        -----
        Examples for the use are scores of the same set of student in
        different exams, or repeated sampling from the same units. The
        test measures whether the average score differs significantly
        across samples (e.g. exams). If we observe a large p-value, for
        example greater than 0.05 or 0.1 then we cannot reject the null
        hypothesis of identical average scores. If the p-value is smaller
        than the threshold, e.g. 1%, 5% or 10%, then we reject the null
        hypothesis of equal averages. Small p-values are associated with
        large t-statistics.
        
        References
        ----------
        https://en.wikipedia.org/wiki/T-test#Dependent_t-test_for_paired_samples
        
        Examples
        --------
        >>> from scipy import stats
        >>> np.random.seed(12345678) # fix random seed to get same numbers
        
        >>> rvs1 = stats.norm.rvs(loc=5,scale=10,size=500)
        >>> rvs2 = (stats.norm.rvs(loc=5,scale=10,size=500) +
        ...         stats.norm.rvs(scale=0.2,size=500))
        >>> stats.ttest_rel(rvs1,rvs2)
        (0.24101764965300962, 0.80964043445811562)
        >>> rvs3 = (stats.norm.rvs(loc=8,scale=10,size=500) +
        ...         stats.norm.rvs(scale=0.2,size=500))
        >>> stats.ttest_rel(rvs1,rvs3)
        (-3.9995108708727933, 7.3082402191726459e-005)
    
    ttvvaarr(a, limits=None, inclusive=(True, True), axis=0, ddof=1)
        Compute the trimmed variance.
        
        This function computes the sample variance of an array of values,
        while ignoring values which are outside of given `limits`.
        
        Parameters
        ----------
        a : array_like
            Array of values.
        limits : None or (lower limit, upper limit), optional
            Values in the input array less than the lower limit or greater than the
            upper limit will be ignored. When limits is None, then all values are
            used. Either of the limit values in the tuple can also be None
            representing a half-open interval.  The default value is None.
        inclusive : (bool, bool), optional
            A tuple consisting of the (lower flag, upper flag).  These flags
            determine whether values exactly equal to the lower or upper limits
            are included.  The default value is (True, True).
        axis : int or None, optional
            Axis along which to operate. Default is 0. If None, compute over the
            whole array `a`.
        ddof : int, optional
            Delta degrees of freedom.  Default is 1.
        
        Returns
        -------
        tvar : float
            Trimmed variance.
        
        Notes
        -----
        `tvar` computes the unbiased sample variance, i.e. it uses a correction
        factor ``n / (n - 1)``.
        
        Examples
        --------
        >>> from scipy import stats
        >>> x = np.arange(20)
        >>> stats.tvar(x)
        35.0
        >>> stats.tvar(x, (3,17))
        20.0
    
    vvaarriiaattiioonn(a, axis=0, nan_policy='propagate')
        Compute the coefficient of variation, the ratio of the biased standard
        deviation to the mean.
        
        Parameters
        ----------
        a : array_like
            Input array.
        axis : int or None, optional
            Axis along which to calculate the coefficient of variation. Default
            is 0. If None, compute over the whole array `a`.
        nan_policy : {'propagate', 'raise', 'omit'}, optional
            Defines how to handle when input contains nan. 'propagate' returns nan,
            'raise' throws an error, 'omit' performs the calculations ignoring nan
            values. Default is 'propagate'.
        
        Returns
        -------
        variation : ndarray
            The calculated variation along the requested axis.
        
        References
        ----------
        .. [1] Zwillinger, D. and Kokoska, S. (2000). CRC Standard
           Probability and Statistics Tables and Formulae. Chapman & Hall: New
           York. 2000.
        
        Examples
        --------
        >>> from scipy.stats import variation
        >>> variation([1, 2, 3, 4, 5])
        0.47140452079103173
    
    wwaasssseerrsstteeiinn__ddiissttaannccee(u_values, v_values, u_weights=None, v_weights=None)
        Compute the first Wasserstein distance between two 1D distributions.
        
        This distance is also known as the earth mover's distance, since it can be
        seen as the minimum amount of "work" required to transform :math:`u` into
        :math:`v`, where "work" is measured as the amount of distribution weight
        that must be moved, multiplied by the distance it has to be moved.
        
        .. versionadded:: 1.0.0
        
        Parameters
        ----------
        u_values, v_values : array_like
            Values observed in the (empirical) distribution.
        u_weights, v_weights : array_like, optional
            Weight for each value. If unspecified, each value is assigned the same
            weight.
            `u_weights` (resp. `v_weights`) must have the same length as
            `u_values` (resp. `v_values`). If the weight sum differs from 1, it
            must still be positive and finite so that the weights can be normalized
            to sum to 1.
        
        Returns
        -------
        distance : float
            The computed distance between the distributions.
        
        Notes
        -----
        The first Wasserstein distance between the distributions :math:`u` and
        :math:`v` is:
        
        .. math::
        
            l_1 (u, v) = \inf_{\pi \in \Gamma (u, v)} \int_{\mathbb{R} \times
            \mathbb{R}} |x-y| \mathrm{d} \pi (x, y)
        
        where :math:`\Gamma (u, v)` is the set of (probability) distributions on
        :math:`\mathbb{R} \times \mathbb{R}` whose marginals are :math:`u` and
        :math:`v` on the first and second factors respectively.
        
        If :math:`U` and :math:`V` are the respective CDFs of :math:`u` and
        :math:`v`, this distance also equals to:
        
        .. math::
        
            l_1(u, v) = \int_{-\infty}^{+\infty} |U-V|
        
        See [2]_ for a proof of the equivalence of both definitions.
        
        The input distributions can be empirical, therefore coming from samples
        whose values are effectively inputs of the function, or they can be seen as
        generalized functions, in which case they are weighted sums of Dirac delta
        functions located at the specified values.
        
        References
        ----------
        .. [1] "Wasserstein metric", http://en.wikipedia.org/wiki/Wasserstein_metric
        .. [2] Ramdas, Garcia, Cuturi "On Wasserstein Two Sample Testing and Related
               Families of Nonparametric Tests" (2015). :arXiv:`1509.02237`.
        
        Examples
        --------
        >>> from scipy.stats import wasserstein_distance
        >>> wasserstein_distance([0, 1, 3], [5, 6, 8])
        5.0
        >>> wasserstein_distance([0, 1], [0, 1], [3, 1], [2, 2])
        0.25
        >>> wasserstein_distance([3.4, 3.9, 7.5, 7.8], [4.5, 1.4],
        ...                      [1.4, 0.9, 3.1, 7.2], [3.2, 3.5])
        4.0781331438047861
    
    wweeiigghhtteeddttaauu(x, y, rank=True, weigher=None, additive=True)
        Compute a weighted version of Kendall's :math:`\tau`.
        
        The weighted :math:`\tau` is a weighted version of Kendall's
        :math:`\tau` in which exchanges of high weight are more influential than
        exchanges of low weight. The default parameters compute the additive
        hyperbolic version of the index, :math:`\tau_\mathrm h`, which has
        been shown to provide the best balance between important and
        unimportant elements [1]_.
        
        The weighting is defined by means of a rank array, which assigns a
        nonnegative rank to each element, and a weigher function, which
        assigns a weight based from the rank to each element. The weight of an
        exchange is then the sum or the product of the weights of the ranks of
        the exchanged elements. The default parameters compute
        :math:`\tau_\mathrm h`: an exchange between elements with rank
        :math:`r` and :math:`s` (starting from zero) has weight
        :math:`1/(r+1) + 1/(s+1)`.
        
        Specifying a rank array is meaningful only if you have in mind an
        external criterion of importance. If, as it usually happens, you do
        not have in mind a specific rank, the weighted :math:`\tau` is
        defined by averaging the values obtained using the decreasing
        lexicographical rank by (`x`, `y`) and by (`y`, `x`). This is the
        behavior with default parameters.
        
        Note that if you are computing the weighted :math:`\tau` on arrays of
        ranks, rather than of scores (i.e., a larger value implies a lower
        rank) you must negate the ranks, so that elements of higher rank are
        associated with a larger value.
        
        Parameters
        ----------
        x, y : array_like
            Arrays of scores, of the same shape. If arrays are not 1-D, they will
            be flattened to 1-D.
        rank: array_like of ints or bool, optional
            A nonnegative rank assigned to each element. If it is None, the
            decreasing lexicographical rank by (`x`, `y`) will be used: elements of
            higher rank will be those with larger `x`-values, using `y`-values to
            break ties (in particular, swapping `x` and `y` will give a different
            result). If it is False, the element indices will be used
            directly as ranks. The default is True, in which case this
            function returns the average of the values obtained using the
            decreasing lexicographical rank by (`x`, `y`) and by (`y`, `x`).
        weigher : callable, optional
            The weigher function. Must map nonnegative integers (zero
            representing the most important element) to a nonnegative weight.
            The default, None, provides hyperbolic weighing, that is,
            rank :math:`r` is mapped to weight :math:`1/(r+1)`.
        additive : bool, optional
            If True, the weight of an exchange is computed by adding the
            weights of the ranks of the exchanged elements; otherwise, the weights
            are multiplied. The default is True.
        
        Returns
        -------
        correlation : float
           The weighted :math:`\tau` correlation index.
        pvalue : float
           Presently ``np.nan``, as the null statistics is unknown (even in the
           additive hyperbolic case).
        
        See also
        --------
        kendalltau : Calculates Kendall's tau.
        spearmanr : Calculates a Spearman rank-order correlation coefficient.
        theilslopes : Computes the Theil-Sen estimator for a set of points (x, y).
        
        Notes
        -----
        This function uses an :math:`O(n \log n)`, mergesort-based algorithm
        [1]_ that is a weighted extension of Knight's algorithm for Kendall's
        :math:`\tau` [2]_. It can compute Shieh's weighted :math:`\tau` [3]_
        between rankings without ties (i.e., permutations) by setting
        `additive` and `rank` to False, as the definition given in [1]_ is a
        generalization of Shieh's.
        
        NaNs are considered the smallest possible score.
        
        .. versionadded:: 0.19.0
        
        References
        ----------
        .. [1] Sebastiano Vigna, "A weighted correlation index for rankings with
               ties", Proceedings of the 24th international conference on World
               Wide Web, pp. 1166-1176, ACM, 2015.
        .. [2] W.R. Knight, "A Computer Method for Calculating Kendall's Tau with
               Ungrouped Data", Journal of the American Statistical Association,
               Vol. 61, No. 314, Part 1, pp. 436-439, 1966.
        .. [3] Grace S. Shieh. "A weighted Kendall's tau statistic", Statistics &
               Probability Letters, Vol. 39, No. 1, pp. 17-24, 1998.
        
        Examples
        --------
        >>> from scipy import stats
        >>> x = [12, 2, 1, 12, 2]
        >>> y = [1, 4, 7, 1, 0]
        >>> tau, p_value = stats.weightedtau(x, y)
        >>> tau
        -0.56694968153682723
        >>> p_value
        nan
        >>> tau, p_value = stats.weightedtau(x, y, additive=False)
        >>> tau
        -0.62205716951801038
        
        NaNs are considered the smallest possible score:
        
        >>> x = [12, 2, 1, 12, 2]
        >>> y = [1, 4, 7, 1, np.nan]
        >>> tau, _ = stats.weightedtau(x, y)
        >>> tau
        -0.56694968153682723
        
        This is exactly Kendall's tau:
        
        >>> x = [12, 2, 1, 12, 2]
        >>> y = [1, 4, 7, 1, 0]
        >>> tau, _ = stats.weightedtau(x, y, weigher=lambda x: 1)
        >>> tau
        -0.47140452079103173
        
        >>> x = [12, 2, 1, 12, 2]
        >>> y = [1, 4, 7, 1, 0]
        >>> stats.weightedtau(x, y, rank=None)
        WeightedTauResult(correlation=-0.4157652301037516, pvalue=nan)
        >>> stats.weightedtau(y, x, rank=None)
        WeightedTauResult(correlation=-0.7181341329699028, pvalue=nan)
    
    wwiillccooxxoonn(x, y=None, zero_method='wilcox', correction=False)
        Calculate the Wilcoxon signed-rank test.
        
        The Wilcoxon signed-rank test tests the null hypothesis that two
        related paired samples come from the same distribution. In particular,
        it tests whether the distribution of the differences x - y is symmetric
        about zero. It is a non-parametric version of the paired T-test.
        
        Parameters
        ----------
        x : array_like
            The first set of measurements.
        y : array_like, optional
            The second set of measurements.  If `y` is not given, then the `x`
            array is considered to be the differences between the two sets of
            measurements.
        zero_method : string, {"pratt", "wilcox", "zsplit"}, optional
            "pratt":
                Pratt treatment: includes zero-differences in the ranking process
                (more conservative)
            "wilcox":
                Wilcox treatment: discards all zero-differences
            "zsplit":
                Zero rank split: just like Pratt, but spliting the zero rank
                between positive and negative ones
        correction : bool, optional
            If True, apply continuity correction by adjusting the Wilcoxon rank
            statistic by 0.5 towards the mean value when computing the
            z-statistic.  Default is False.
        
        Returns
        -------
        statistic : float
            The sum of the ranks of the differences above or below zero, whichever
            is smaller.
        pvalue : float
            The two-sided p-value for the test.
        
        Notes
        -----
        Because the normal approximation is used for the calculations, the
        samples used should be large.  A typical rule is to require that
        n > 20.
        
        References
        ----------
        .. [1] http://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test
    
    zzmmaapp(scores, compare, axis=0, ddof=0)
        Calculate the relative z-scores.
        
        Return an array of z-scores, i.e., scores that are standardized to
        zero mean and unit variance, where mean and variance are calculated
        from the comparison array.
        
        Parameters
        ----------
        scores : array_like
            The input for which z-scores are calculated.
        compare : array_like
            The input from which the mean and standard deviation of the
            normalization are taken; assumed to have the same dimension as
            `scores`.
        axis : int or None, optional
            Axis over which mean and variance of `compare` are calculated.
            Default is 0. If None, compute over the whole array `scores`.
        ddof : int, optional
            Degrees of freedom correction in the calculation of the
            standard deviation. Default is 0.
        
        Returns
        -------
        zscore : array_like
            Z-scores, in the same shape as `scores`.
        
        Notes
        -----
        This function preserves ndarray subclasses, and works also with
        matrices and masked arrays (it uses `asanyarray` instead of
        `asarray` for parameters).
        
        Examples
        --------
        >>> from scipy.stats import zmap
        >>> a = [0.5, 2.0, 2.5, 3]
        >>> b = [0, 1, 2, 3, 4]
        >>> zmap(a, b)
        array([-1.06066017,  0.        ,  0.35355339,  0.70710678])
    
    zzssccoorree(a, axis=0, ddof=0)
        Calculate the z score of each value in the sample, relative to the
        sample mean and standard deviation.
        
        Parameters
        ----------
        a : array_like
            An array like object containing the sample data.
        axis : int or None, optional
            Axis along which to operate. Default is 0. If None, compute over
            the whole array `a`.
        ddof : int, optional
            Degrees of freedom correction in the calculation of the
            standard deviation. Default is 0.
        
        Returns
        -------
        zscore : array_like
            The z-scores, standardized by mean and standard deviation of
            input array `a`.
        
        Notes
        -----
        This function preserves ndarray subclasses, and works also with
        matrices and masked arrays (it uses `asanyarray` instead of
        `asarray` for parameters).
        
        Examples
        --------
        >>> a = np.array([ 0.7972,  0.0767,  0.4383,  0.7866,  0.8091,
        ...                0.1954,  0.6307,  0.6599,  0.1065,  0.0508])
        >>> from scipy import stats
        >>> stats.zscore(a)
        array([ 1.1273, -1.247 , -0.0552,  1.0923,  1.1664, -0.8559,  0.5786,
                0.6748, -1.1488, -1.3324])
        
        Computing along a specified axis, using n-1 degrees of freedom
        (``ddof=1``) to calculate the standard deviation:
        
        >>> b = np.array([[ 0.3148,  0.0478,  0.6243,  0.4608],
        ...               [ 0.7149,  0.0775,  0.6072,  0.9656],
        ...               [ 0.6341,  0.1403,  0.9759,  0.4064],
        ...               [ 0.5918,  0.6948,  0.904 ,  0.3721],
        ...               [ 0.0921,  0.2481,  0.1188,  0.1366]])
        >>> stats.zscore(b, axis=1, ddof=1)
        array([[-0.19264823, -1.28415119,  1.07259584,  0.40420358],
               [ 0.33048416, -1.37380874,  0.04251374,  1.00081084],
               [ 0.26796377, -1.12598418,  1.23283094, -0.37481053],
               [-0.22095197,  0.24468594,  1.19042819, -1.21416216],
               [-0.82780366,  1.4457416 , -0.43867764, -0.1792603 ]])

DDAATTAA
    ____aallll____ = ['absolute_import', 'alpha', 'anderson', 'anderson_ksamp', '...
    aabbssoolluuttee__iimmppoorrtt = _Feature((2, 5, 0, 'alpha', 1), (3, 0, 0, 'alpha', 0...
    aallpphhaa = <scipy.stats._continuous_distns.alpha_gen object>
    aanngglliitt = <scipy.stats._continuous_distns.anglit_gen object>
    aarrccssiinnee = <scipy.stats._continuous_distns.arcsine_gen object>
    aarrgguuss = <scipy.stats._continuous_distns.argus_gen object>
    bbeerrnnoouullllii = <scipy.stats._discrete_distns.bernoulli_gen object>
    bbeettaa = <scipy.stats._continuous_distns.beta_gen object>
    bbeettaapprriimmee = <scipy.stats._continuous_distns.betaprime_gen object>
    bbiinnoomm = <scipy.stats._discrete_distns.binom_gen object>
    bboollttzzmmaannnn = <scipy.stats._discrete_distns.boltzmann_gen object>
    bbrraaddffoorrdd = <scipy.stats._continuous_distns.bradford_gen object>
    bbuurrrr = <scipy.stats._continuous_distns.burr_gen object>
    bbuurrrr1122 = <scipy.stats._continuous_distns.burr12_gen object>
    ccaauucchhyy = <scipy.stats._continuous_distns.cauchy_gen object>
    cchhii = <scipy.stats._continuous_distns.chi_gen object>
    cchhii22 = <scipy.stats._continuous_distns.chi2_gen object>
    ccoossiinnee = <scipy.stats._continuous_distns.cosine_gen object>
    ccrryyssttaallbbaallll = <scipy.stats._continuous_distns.crystalball_gen object>
    ddggaammmmaa = <scipy.stats._continuous_distns.dgamma_gen object>
    ddiirriicchhlleett = <scipy.stats._multivariate.dirichlet_gen object>
    ddiivviissiioonn = _Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192...
    ddllaappllaaccee = <scipy.stats._discrete_distns.dlaplace_gen object>
    ddwweeiibbuullll = <scipy.stats._continuous_distns.dweibull_gen object>
    eerrllaanngg = <scipy.stats._continuous_distns.erlang_gen object>
    eexxppoonn = <scipy.stats._continuous_distns.expon_gen object>
    eexxppoonnnnoorrmm = <scipy.stats._continuous_distns.exponnorm_gen object>
    eexxppoonnppooww = <scipy.stats._continuous_distns.exponpow_gen object>
    eexxppoonnwweeiibb = <scipy.stats._continuous_distns.exponweib_gen object>
    ff = <scipy.stats._continuous_distns.f_gen object>
    ffaattiigguueelliiffee = <scipy.stats._continuous_distns.fatiguelife_gen object>
    ffiisskk = <scipy.stats._continuous_distns.fisk_gen object>
    ffoollddccaauucchhyy = <scipy.stats._continuous_distns.foldcauchy_gen object>
    ffoollddnnoorrmm = <scipy.stats._continuous_distns.foldnorm_gen object>
    ffrreecchheett__ll = <scipy.stats._continuous_distns.frechet_l_gen object>
    ffrreecchheett__rr = <scipy.stats._continuous_distns.frechet_r_gen object>
    ggaammmmaa = <scipy.stats._continuous_distns.gamma_gen object>
    ggaauusssshhyyppeerr = <scipy.stats._continuous_distns.gausshyper_gen object>
    ggeenneexxppoonn = <scipy.stats._continuous_distns.genexpon_gen object>
    ggeenneexxttrreemmee = <scipy.stats._continuous_distns.genextreme_gen object>
    ggeennggaammmmaa = <scipy.stats._continuous_distns.gengamma_gen object>
    ggeennhhaallffllooggiissttiicc = <scipy.stats._continuous_distns.genhalflogistic_gen ...
    ggeennllooggiissttiicc = <scipy.stats._continuous_distns.genlogistic_gen object>
    ggeennnnoorrmm = <scipy.stats._continuous_distns.gennorm_gen object>
    ggeennppaarreettoo = <scipy.stats._continuous_distns.genpareto_gen object>
    ggeeoomm = <scipy.stats._discrete_distns.geom_gen object>
    ggiillbbrraatt = <scipy.stats._continuous_distns.gilbrat_gen object>
    ggoommppeerrttzz = <scipy.stats._continuous_distns.gompertz_gen object>
    gguummbbeell__ll = <scipy.stats._continuous_distns.gumbel_l_gen object>
    gguummbbeell__rr = <scipy.stats._continuous_distns.gumbel_r_gen object>
    hhaallffccaauucchhyy = <scipy.stats._continuous_distns.halfcauchy_gen object>
    hhaallffggeennnnoorrmm = <scipy.stats._continuous_distns.halfgennorm_gen object>
    hhaallffllooggiissttiicc = <scipy.stats._continuous_distns.halflogistic_gen object...
    hhaallffnnoorrmm = <scipy.stats._continuous_distns.halfnorm_gen object>
    hhyyppeerrggeeoomm = <scipy.stats._discrete_distns.hypergeom_gen object>
    hhyyppsseeccaanntt = <scipy.stats._continuous_distns.hypsecant_gen object>
    iinnvvggaammmmaa = <scipy.stats._continuous_distns.invgamma_gen object>
    iinnvvggaauussss = <scipy.stats._continuous_distns.invgauss_gen object>
    iinnvvwweeiibbuullll = <scipy.stats._continuous_distns.invweibull_gen object>
    iinnvvwwiisshhaarrtt = <scipy.stats._multivariate.invwishart_gen object>
    jjoohhnnssoonnssbb = <scipy.stats._continuous_distns.johnsonsb_gen object>
    jjoohhnnssoonnssuu = <scipy.stats._continuous_distns.johnsonsu_gen object>
    kkaappppaa33 = <scipy.stats._continuous_distns.kappa3_gen object>
    kkaappppaa44 = <scipy.stats._continuous_distns.kappa4_gen object>
    kkssoonnee = <scipy.stats._continuous_distns.ksone_gen object>
    kkssttwwoobbiiggnn = <scipy.stats._continuous_distns.kstwobign_gen object>
    llaappllaaccee = <scipy.stats._continuous_distns.laplace_gen object>
    lleevvyy = <scipy.stats._continuous_distns.levy_gen object>
    lleevvyy__ll = <scipy.stats._continuous_distns.levy_l_gen object>
    lleevvyy__ssttaabbllee = <scipy.stats._continuous_distns.levy_stable_gen object>
    llooggggaammmmaa = <scipy.stats._continuous_distns.loggamma_gen object>
    llooggiissttiicc = <scipy.stats._continuous_distns.logistic_gen object>
    llooggllaappllaaccee = <scipy.stats._continuous_distns.loglaplace_gen object>
    llooggnnoorrmm = <scipy.stats._continuous_distns.lognorm_gen object>
    llooggsseerr = <scipy.stats._discrete_distns.logser_gen object>
    lloommaaxx = <scipy.stats._continuous_distns.lomax_gen object>
    mmaattrriixx__nnoorrmmaall = <scipy.stats._multivariate.matrix_normal_gen object>
    mmaaxxwweellll = <scipy.stats._continuous_distns.maxwell_gen object>
    mmiieellkkee = <scipy.stats._continuous_distns.mielke_gen object>
    mmooyyaall = <scipy.stats._continuous_distns.moyal_gen object>
    mmuullttiinnoommiiaall = <scipy.stats._multivariate.multinomial_gen object>
    mmuullttiivvaarriiaattee__nnoorrmmaall = <scipy.stats._multivariate.multivariate_normal_g...
    nnaakkaaggaammii = <scipy.stats._continuous_distns.nakagami_gen object>
    nnbbiinnoomm = <scipy.stats._discrete_distns.nbinom_gen object>
    nnccff = <scipy.stats._continuous_distns.ncf_gen object>
    nncctt = <scipy.stats._continuous_distns.nct_gen object>
    nnccxx22 = <scipy.stats._continuous_distns.ncx2_gen object>
    nnoorrmm = <scipy.stats._continuous_distns.norm_gen object>
    nnoorrmmiinnvvggaauussss = <scipy.stats._continuous_distns.norminvgauss_gen object...
    oorrtthhoo__ggrroouupp = <scipy.stats._multivariate.ortho_group_gen object>
    ppaarreettoo = <scipy.stats._continuous_distns.pareto_gen object>
    ppeeaarrssoonn33 = <scipy.stats._continuous_distns.pearson3_gen object>
    ppllaanncckk = <scipy.stats._discrete_distns.planck_gen object>
    ppooiissssoonn = <scipy.stats._discrete_distns.poisson_gen object>
    ppoowweerrllaaww = <scipy.stats._continuous_distns.powerlaw_gen object>
    ppoowweerrllooggnnoorrmm = <scipy.stats._continuous_distns.powerlognorm_gen object...
    ppoowweerrnnoorrmm = <scipy.stats._continuous_distns.powernorm_gen object>
    pprriinntt__ffuunnccttiioonn = _Feature((2, 6, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0)...
    rraannddiinntt = <scipy.stats._discrete_distns.randint_gen object>
    rraannddoomm__ccoorrrreellaattiioonn = <scipy.stats._multivariate.random_correlation_gen...
    rraayylleeiigghh = <scipy.stats._continuous_distns.rayleigh_gen object>
    rrddiisstt = <scipy.stats._continuous_distns.rdist_gen object>
    rreecciippiinnvvggaauussss = <scipy.stats._continuous_distns.recipinvgauss_gen obje...
    rreecciipprrooccaall = <scipy.stats._continuous_distns.reciprocal_gen object>
    rriiccee = <scipy.stats._continuous_distns.rice_gen object>
    sseemmiicciirrccuullaarr = <scipy.stats._continuous_distns.semicircular_gen object...
    sskkeellllaamm = <scipy.stats._discrete_distns.skellam_gen object>
    sskkeewwnnoorrmm = <scipy.stats._continuous_distns.skew_norm_gen object>
    ssppeecciiaall__oorrtthhoo__ggrroouupp = <scipy.stats._multivariate.special_ortho_group_g...
    tt = <scipy.stats._continuous_distns.t_gen object>
    ttrraappzz = <scipy.stats._continuous_distns.trapz_gen object>
    ttrriiaanngg = <scipy.stats._continuous_distns.triang_gen object>
    ttrruunncceexxppoonn = <scipy.stats._continuous_distns.truncexpon_gen object>
    ttrruunnccnnoorrmm = <scipy.stats._continuous_distns.truncnorm_gen object>
    ttuukkeeyyllaammbbddaa = <scipy.stats._continuous_distns.tukeylambda_gen object>
    uunniiffoorrmm = <scipy.stats._continuous_distns.uniform_gen object>
    uunniittaarryy__ggrroouupp = <scipy.stats._multivariate.unitary_group_gen object>
    vvoonnmmiisseess = <scipy.stats._continuous_distns.vonmises_gen object>
    vvoonnmmiisseess__lliinnee = <scipy.stats._continuous_distns.vonmises_gen object>
    wwaalldd = <scipy.stats._continuous_distns.wald_gen object>
    wweeiibbuullll__mmaaxx = <scipy.stats._continuous_distns.weibull_max_gen object>
    wweeiibbuullll__mmiinn = <scipy.stats._continuous_distns.weibull_min_gen object>
    wwiisshhaarrtt = <scipy.stats._multivariate.wishart_gen object>
    wwrraappccaauucchhyy = <scipy.stats._continuous_distns.wrapcauchy_gen object>
    zziippff = <scipy.stats._discrete_distns.zipf_gen object>

FFIILLEE
    /home/william/anaconda3/lib/python3.7/site-packages/scipy/stats/__init__.py

